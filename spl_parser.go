// Code generated from SPLParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package spl // SPLParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SPLParser struct {
	*antlr.BaseParser
}

var SPLParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func splparserParserInit() {
	staticData := &SPLParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "'='", "'!='", "'<'", "'>'",
		"'<='", "'>='", "", "", "", "'|'", "'('", "')'", "'['", "']'", "','",
		"':'", "'\"'", "'+'", "'-'", "'/'", "'%'", "", "", "", "'*'", "'$'",
		"", "'.'",
	}
	staticData.SymbolicNames = []string{
		"", "AND", "OR", "NOT", "BY", "AS", "IN", "WHERE", "SEARCH", "EVAL",
		"STATS", "TABLE", "FIELDS", "RENAME", "REX", "DEDUP", "SORT", "HEAD",
		"TAIL", "TOP", "RARE", "LOOKUP", "JOIN", "APPEND", "TRANSACTION", "SPATH",
		"EVENTSTATS", "STREAMSTATS", "TIMECHART", "CHART", "FILLNULL", "MAKEMV",
		"MVEXPAND", "FORMAT", "CONVERT", "BUCKET", "BIN", "OVER", "REST", "TSTATS",
		"FROM", "GROUPBY", "MSTATS", "INPUTLOOKUP", "EQ", "NEQ", "LT", "GT",
		"LTE", "GTE", "LIKE", "MATCH", "CIDRMATCH", "PIPE", "LPAREN", "RPAREN",
		"LBRACKET", "RBRACKET", "COMMA", "COLON", "DQUOTE", "PLUS", "MINUS",
		"SLASH", "PERCENT", "QUOTED_STRING", "TIME_SPAN", "NUMBER", "WILDCARD",
		"DOLLAR", "IDENTIFIER", "DOT", "REST_PATH", "MACRO", "TIME_MODIFIER",
		"WS", "LINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"query", "pipelineStage", "searchCommand", "whereCommand", "evalCommand",
		"evalAssignment", "statsCommand", "statsFunction", "tableCommand", "fieldsCommand",
		"renameCommand", "renameSpec", "rexCommand", "rexOption", "dedupCommand",
		"dedupOption", "sortCommand", "sortField", "headCommand", "tailCommand",
		"topCommand", "rareCommand", "lookupCommand", "lookupOption", "joinCommand",
		"joinOption", "appendCommand", "transactionCommand", "transactionOption",
		"spathCommand", "spathOption", "eventstatsCommand", "streamstatsCommand",
		"timechartCommand", "timechartOption", "chartCommand", "fillnullCommand",
		"fillnullOption", "makemvCommand", "makemvOption", "mvexpandCommand",
		"formatCommand", "formatOption", "convertCommand", "convertOption",
		"convertFunction", "bucketCommand", "bucketOption", "restCommand", "restArg",
		"tstatsCommand", "tstatsPreOption", "tstatsDatamodel", "tstatsPostOption",
		"mstatsCommand", "inputlookupCommand", "inputlookupOption", "genericCommand",
		"genericArg", "subsearch", "searchExpression", "searchTerm", "condition",
		"comparisonOp", "logicalOp", "expression", "orExpression", "andExpression",
		"notExpression", "comparisonExpression", "additiveExpression", "multiplicativeExpression",
		"unaryExpression", "primaryExpression", "functionCall", "argumentList",
		"value", "colonValue", "extendedIdentifier", "wildcardValue", "bareWord",
		"fieldName", "fieldList", "fieldOrQuoted", "valueList",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 76, 990, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 1, 0, 3, 0, 172, 8, 0, 1, 0, 1, 0, 1, 0, 5, 0, 177, 8, 0, 10,
		0, 12, 0, 180, 9, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 3, 1, 216, 8, 1, 1, 2, 3, 2, 219, 8, 2, 1, 2, 1, 2, 1, 3, 1, 3,
		1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 230, 8, 4, 10, 4, 12, 4, 233, 9, 4,
		1, 5, 1, 5, 3, 5, 237, 8, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6,
		5, 6, 246, 8, 6, 10, 6, 12, 6, 249, 9, 6, 1, 6, 1, 6, 3, 6, 253, 8, 6,
		1, 7, 1, 7, 1, 7, 3, 7, 258, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 263, 8, 7, 1,
		7, 1, 7, 1, 7, 3, 7, 268, 8, 7, 3, 7, 270, 8, 7, 1, 8, 1, 8, 1, 8, 1, 9,
		1, 9, 3, 9, 277, 8, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 285,
		8, 10, 10, 10, 12, 10, 288, 9, 10, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 294,
		8, 11, 1, 12, 1, 12, 5, 12, 298, 8, 12, 10, 12, 12, 12, 301, 9, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 308, 8, 12, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 3, 13, 315, 8, 13, 1, 14, 1, 14, 3, 14, 319, 8, 14, 1, 14,
		1, 14, 5, 14, 323, 8, 14, 10, 14, 12, 14, 326, 9, 14, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 333, 8, 15, 1, 16, 1, 16, 3, 16, 337, 8, 16, 1,
		16, 1, 16, 1, 16, 5, 16, 342, 8, 16, 10, 16, 12, 16, 345, 9, 16, 1, 17,
		3, 17, 348, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 3, 18, 354, 8, 18, 1, 19,
		1, 19, 3, 19, 358, 8, 19, 1, 20, 1, 20, 3, 20, 362, 8, 20, 1, 20, 1, 20,
		1, 20, 3, 20, 367, 8, 20, 1, 21, 1, 21, 3, 21, 371, 8, 21, 1, 21, 1, 21,
		1, 21, 3, 21, 376, 8, 21, 1, 22, 1, 22, 5, 22, 380, 8, 22, 10, 22, 12,
		22, 383, 9, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		3, 23, 393, 8, 23, 1, 24, 1, 24, 5, 24, 397, 8, 24, 10, 24, 12, 24, 400,
		9, 24, 1, 24, 1, 24, 1, 24, 5, 24, 405, 8, 24, 10, 24, 12, 24, 408, 9,
		24, 1, 24, 1, 24, 1, 24, 3, 24, 413, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 3, 25, 420, 8, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 5,
		27, 428, 8, 27, 10, 27, 12, 27, 431, 9, 27, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 3, 28, 439, 8, 28, 1, 29, 1, 29, 5, 29, 443, 8, 29, 10, 29,
		12, 29, 446, 9, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 452, 8, 30, 1, 31,
		1, 31, 1, 31, 1, 31, 5, 31, 458, 8, 31, 10, 31, 12, 31, 461, 9, 31, 1,
		31, 1, 31, 3, 31, 465, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 471, 8,
		32, 10, 32, 12, 32, 474, 9, 32, 1, 32, 1, 32, 3, 32, 478, 8, 32, 1, 33,
		1, 33, 5, 33, 482, 8, 33, 10, 33, 12, 33, 485, 9, 33, 1, 33, 1, 33, 1,
		33, 3, 33, 490, 8, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34,
		498, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 504, 8, 35, 1, 35, 1, 35,
		3, 35, 508, 8, 35, 1, 36, 1, 36, 5, 36, 512, 8, 36, 10, 36, 12, 36, 515,
		9, 36, 1, 36, 3, 36, 518, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1,
		38, 5, 38, 526, 8, 38, 10, 38, 12, 38, 529, 9, 38, 1, 38, 1, 38, 1, 39,
		1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 538, 8, 39, 1, 40, 1, 40, 1, 40, 1,
		41, 1, 41, 5, 41, 545, 8, 41, 10, 41, 12, 41, 548, 9, 41, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 43, 1, 43, 5, 43, 556, 8, 43, 10, 43, 12, 43, 559, 9,
		43, 1, 43, 1, 43, 1, 43, 5, 43, 564, 8, 43, 10, 43, 12, 43, 567, 9, 43,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 3, 45, 580, 8, 45, 3, 45, 582, 8, 45, 1, 46, 1, 46, 1, 46, 5, 46, 587,
		8, 46, 10, 46, 12, 46, 590, 9, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1,
		48, 5, 48, 598, 8, 48, 10, 48, 12, 48, 601, 9, 48, 1, 49, 1, 49, 1, 49,
		3, 49, 606, 8, 49, 1, 49, 1, 49, 3, 49, 610, 8, 49, 1, 49, 1, 49, 3, 49,
		614, 8, 49, 1, 50, 1, 50, 5, 50, 618, 8, 50, 10, 50, 12, 50, 621, 9, 50,
		1, 50, 1, 50, 3, 50, 625, 8, 50, 1, 50, 5, 50, 628, 8, 50, 10, 50, 12,
		50, 631, 9, 50, 1, 50, 1, 50, 3, 50, 635, 8, 50, 1, 50, 1, 50, 3, 50, 639,
		8, 50, 1, 50, 1, 50, 1, 50, 4, 50, 644, 8, 50, 11, 50, 12, 50, 645, 3,
		50, 648, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 656, 8,
		51, 1, 51, 3, 51, 659, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52,
		666, 8, 52, 10, 52, 12, 52, 669, 9, 52, 1, 52, 1, 52, 1, 52, 5, 52, 674,
		8, 52, 10, 52, 12, 52, 677, 9, 52, 3, 52, 679, 8, 52, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 3, 53, 687, 8, 53, 1, 54, 1, 54, 5, 54, 691, 8,
		54, 10, 54, 12, 54, 694, 9, 54, 1, 54, 1, 54, 3, 54, 698, 8, 54, 1, 54,
		5, 54, 701, 8, 54, 10, 54, 12, 54, 704, 9, 54, 1, 54, 1, 54, 3, 54, 708,
		8, 54, 1, 54, 1, 54, 1, 54, 4, 54, 713, 8, 54, 11, 54, 12, 54, 714, 3,
		54, 717, 8, 54, 1, 55, 1, 55, 5, 55, 721, 8, 55, 10, 55, 12, 55, 724, 9,
		55, 1, 55, 1, 55, 1, 55, 3, 55, 729, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 736, 8, 56, 1, 57, 1, 57, 5, 57, 740, 8, 57, 10, 57, 12,
		57, 743, 9, 57, 1, 58, 1, 58, 1, 58, 3, 58, 748, 8, 58, 1, 58, 1, 58, 3,
		58, 752, 8, 58, 3, 58, 754, 8, 58, 1, 58, 3, 58, 757, 8, 58, 1, 58, 1,
		58, 1, 58, 5, 58, 762, 8, 58, 10, 58, 12, 58, 765, 9, 58, 1, 58, 3, 58,
		768, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 3, 60, 776, 8, 60,
		1, 60, 5, 60, 779, 8, 60, 10, 60, 12, 60, 782, 9, 60, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 794, 8, 61,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 811, 8, 62, 1, 63, 1, 63, 1, 64,
		1, 64, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 5, 66, 822, 8, 66, 10, 66, 12,
		66, 825, 9, 66, 1, 67, 1, 67, 3, 67, 829, 8, 67, 1, 67, 5, 67, 832, 8,
		67, 10, 67, 12, 67, 835, 9, 67, 1, 68, 1, 68, 1, 68, 3, 68, 840, 8, 68,
		1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 847, 8, 69, 3, 69, 849, 8, 69,
		1, 70, 1, 70, 1, 70, 5, 70, 854, 8, 70, 10, 70, 12, 70, 857, 9, 70, 1,
		71, 1, 71, 1, 71, 5, 71, 862, 8, 71, 10, 71, 12, 71, 865, 9, 71, 1, 72,
		1, 72, 1, 72, 3, 72, 870, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 3, 73, 880, 8, 73, 1, 74, 1, 74, 1, 74, 3, 74, 885, 8,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 891, 8, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 3, 74, 909, 8, 74, 1, 75, 1, 75, 1, 75, 5, 75, 914, 8,
		75, 10, 75, 12, 75, 917, 9, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76,
		3, 76, 925, 8, 76, 1, 77, 1, 77, 1, 77, 4, 77, 930, 8, 77, 11, 77, 12,
		77, 931, 1, 78, 1, 78, 1, 78, 5, 78, 937, 8, 78, 10, 78, 12, 78, 940, 9,
		78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79,
		1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 958, 8, 79, 1, 80, 1,
		80, 1, 80, 1, 80, 3, 80, 964, 8, 80, 1, 81, 1, 81, 1, 82, 1, 82, 3, 82,
		970, 8, 82, 1, 82, 5, 82, 973, 8, 82, 10, 82, 12, 82, 976, 9, 82, 1, 83,
		1, 83, 3, 83, 980, 8, 83, 1, 84, 1, 84, 1, 84, 5, 84, 985, 8, 84, 10, 84,
		12, 84, 988, 9, 84, 1, 84, 0, 0, 85, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,
		20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
		56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
		92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 0, 13, 1, 0, 61, 62, 2, 0,
		65, 65, 67, 67, 3, 0, 65, 65, 67, 67, 70, 70, 1, 0, 35, 36, 2, 0, 65, 67,
		70, 70, 2, 0, 4, 4, 41, 41, 2, 0, 65, 65, 70, 70, 1, 0, 44, 49, 1, 0, 1,
		2, 2, 0, 61, 62, 71, 71, 2, 0, 63, 64, 68, 68, 1, 0, 62, 63, 3, 0, 40,
		40, 42, 43, 70, 70, 1097, 0, 171, 1, 0, 0, 0, 2, 215, 1, 0, 0, 0, 4, 218,
		1, 0, 0, 0, 6, 222, 1, 0, 0, 0, 8, 225, 1, 0, 0, 0, 10, 236, 1, 0, 0, 0,
		12, 241, 1, 0, 0, 0, 14, 269, 1, 0, 0, 0, 16, 271, 1, 0, 0, 0, 18, 274,
		1, 0, 0, 0, 20, 280, 1, 0, 0, 0, 22, 289, 1, 0, 0, 0, 24, 295, 1, 0, 0,
		0, 26, 309, 1, 0, 0, 0, 28, 316, 1, 0, 0, 0, 30, 327, 1, 0, 0, 0, 32, 334,
		1, 0, 0, 0, 34, 347, 1, 0, 0, 0, 36, 351, 1, 0, 0, 0, 38, 355, 1, 0, 0,
		0, 40, 359, 1, 0, 0, 0, 42, 368, 1, 0, 0, 0, 44, 377, 1, 0, 0, 0, 46, 387,
		1, 0, 0, 0, 48, 412, 1, 0, 0, 0, 50, 414, 1, 0, 0, 0, 52, 421, 1, 0, 0,
		0, 54, 424, 1, 0, 0, 0, 56, 432, 1, 0, 0, 0, 58, 440, 1, 0, 0, 0, 60, 447,
		1, 0, 0, 0, 62, 453, 1, 0, 0, 0, 64, 466, 1, 0, 0, 0, 66, 479, 1, 0, 0,
		0, 68, 491, 1, 0, 0, 0, 70, 499, 1, 0, 0, 0, 72, 509, 1, 0, 0, 0, 74, 519,
		1, 0, 0, 0, 76, 523, 1, 0, 0, 0, 78, 532, 1, 0, 0, 0, 80, 539, 1, 0, 0,
		0, 82, 542, 1, 0, 0, 0, 84, 549, 1, 0, 0, 0, 86, 553, 1, 0, 0, 0, 88, 568,
		1, 0, 0, 0, 90, 572, 1, 0, 0, 0, 92, 583, 1, 0, 0, 0, 94, 591, 1, 0, 0,
		0, 96, 595, 1, 0, 0, 0, 98, 613, 1, 0, 0, 0, 100, 615, 1, 0, 0, 0, 102,
		658, 1, 0, 0, 0, 104, 678, 1, 0, 0, 0, 106, 680, 1, 0, 0, 0, 108, 688,
		1, 0, 0, 0, 110, 718, 1, 0, 0, 0, 112, 730, 1, 0, 0, 0, 114, 737, 1, 0,
		0, 0, 116, 767, 1, 0, 0, 0, 118, 769, 1, 0, 0, 0, 120, 773, 1, 0, 0, 0,
		122, 793, 1, 0, 0, 0, 124, 810, 1, 0, 0, 0, 126, 812, 1, 0, 0, 0, 128,
		814, 1, 0, 0, 0, 130, 816, 1, 0, 0, 0, 132, 818, 1, 0, 0, 0, 134, 826,
		1, 0, 0, 0, 136, 839, 1, 0, 0, 0, 138, 848, 1, 0, 0, 0, 140, 850, 1, 0,
		0, 0, 142, 858, 1, 0, 0, 0, 144, 869, 1, 0, 0, 0, 146, 879, 1, 0, 0, 0,
		148, 908, 1, 0, 0, 0, 150, 910, 1, 0, 0, 0, 152, 924, 1, 0, 0, 0, 154,
		926, 1, 0, 0, 0, 156, 933, 1, 0, 0, 0, 158, 957, 1, 0, 0, 0, 160, 963,
		1, 0, 0, 0, 162, 965, 1, 0, 0, 0, 164, 967, 1, 0, 0, 0, 166, 979, 1, 0,
		0, 0, 168, 981, 1, 0, 0, 0, 170, 172, 5, 53, 0, 0, 171, 170, 1, 0, 0, 0,
		171, 172, 1, 0, 0, 0, 172, 173, 1, 0, 0, 0, 173, 178, 3, 2, 1, 0, 174,
		175, 5, 53, 0, 0, 175, 177, 3, 2, 1, 0, 176, 174, 1, 0, 0, 0, 177, 180,
		1, 0, 0, 0, 178, 176, 1, 0, 0, 0, 178, 179, 1, 0, 0, 0, 179, 1, 1, 0, 0,
		0, 180, 178, 1, 0, 0, 0, 181, 216, 3, 4, 2, 0, 182, 216, 3, 6, 3, 0, 183,
		216, 3, 8, 4, 0, 184, 216, 3, 12, 6, 0, 185, 216, 3, 16, 8, 0, 186, 216,
		3, 18, 9, 0, 187, 216, 3, 20, 10, 0, 188, 216, 3, 24, 12, 0, 189, 216,
		3, 28, 14, 0, 190, 216, 3, 32, 16, 0, 191, 216, 3, 36, 18, 0, 192, 216,
		3, 38, 19, 0, 193, 216, 3, 40, 20, 0, 194, 216, 3, 42, 21, 0, 195, 216,
		3, 44, 22, 0, 196, 216, 3, 48, 24, 0, 197, 216, 3, 52, 26, 0, 198, 216,
		3, 54, 27, 0, 199, 216, 3, 58, 29, 0, 200, 216, 3, 62, 31, 0, 201, 216,
		3, 64, 32, 0, 202, 216, 3, 66, 33, 0, 203, 216, 3, 70, 35, 0, 204, 216,
		3, 72, 36, 0, 205, 216, 3, 76, 38, 0, 206, 216, 3, 80, 40, 0, 207, 216,
		3, 82, 41, 0, 208, 216, 3, 86, 43, 0, 209, 216, 3, 92, 46, 0, 210, 216,
		3, 96, 48, 0, 211, 216, 3, 100, 50, 0, 212, 216, 3, 108, 54, 0, 213, 216,
		3, 110, 55, 0, 214, 216, 3, 114, 57, 0, 215, 181, 1, 0, 0, 0, 215, 182,
		1, 0, 0, 0, 215, 183, 1, 0, 0, 0, 215, 184, 1, 0, 0, 0, 215, 185, 1, 0,
		0, 0, 215, 186, 1, 0, 0, 0, 215, 187, 1, 0, 0, 0, 215, 188, 1, 0, 0, 0,
		215, 189, 1, 0, 0, 0, 215, 190, 1, 0, 0, 0, 215, 191, 1, 0, 0, 0, 215,
		192, 1, 0, 0, 0, 215, 193, 1, 0, 0, 0, 215, 194, 1, 0, 0, 0, 215, 195,
		1, 0, 0, 0, 215, 196, 1, 0, 0, 0, 215, 197, 1, 0, 0, 0, 215, 198, 1, 0,
		0, 0, 215, 199, 1, 0, 0, 0, 215, 200, 1, 0, 0, 0, 215, 201, 1, 0, 0, 0,
		215, 202, 1, 0, 0, 0, 215, 203, 1, 0, 0, 0, 215, 204, 1, 0, 0, 0, 215,
		205, 1, 0, 0, 0, 215, 206, 1, 0, 0, 0, 215, 207, 1, 0, 0, 0, 215, 208,
		1, 0, 0, 0, 215, 209, 1, 0, 0, 0, 215, 210, 1, 0, 0, 0, 215, 211, 1, 0,
		0, 0, 215, 212, 1, 0, 0, 0, 215, 213, 1, 0, 0, 0, 215, 214, 1, 0, 0, 0,
		216, 3, 1, 0, 0, 0, 217, 219, 5, 8, 0, 0, 218, 217, 1, 0, 0, 0, 218, 219,
		1, 0, 0, 0, 219, 220, 1, 0, 0, 0, 220, 221, 3, 120, 60, 0, 221, 5, 1, 0,
		0, 0, 222, 223, 5, 7, 0, 0, 223, 224, 3, 130, 65, 0, 224, 7, 1, 0, 0, 0,
		225, 226, 5, 9, 0, 0, 226, 231, 3, 10, 5, 0, 227, 228, 5, 58, 0, 0, 228,
		230, 3, 10, 5, 0, 229, 227, 1, 0, 0, 0, 230, 233, 1, 0, 0, 0, 231, 229,
		1, 0, 0, 0, 231, 232, 1, 0, 0, 0, 232, 9, 1, 0, 0, 0, 233, 231, 1, 0, 0,
		0, 234, 237, 3, 162, 81, 0, 235, 237, 5, 65, 0, 0, 236, 234, 1, 0, 0, 0,
		236, 235, 1, 0, 0, 0, 237, 238, 1, 0, 0, 0, 238, 239, 5, 44, 0, 0, 239,
		240, 3, 130, 65, 0, 240, 11, 1, 0, 0, 0, 241, 242, 5, 10, 0, 0, 242, 247,
		3, 14, 7, 0, 243, 244, 5, 58, 0, 0, 244, 246, 3, 14, 7, 0, 245, 243, 1,
		0, 0, 0, 246, 249, 1, 0, 0, 0, 247, 245, 1, 0, 0, 0, 247, 248, 1, 0, 0,
		0, 248, 252, 1, 0, 0, 0, 249, 247, 1, 0, 0, 0, 250, 251, 5, 4, 0, 0, 251,
		253, 3, 164, 82, 0, 252, 250, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 13,
		1, 0, 0, 0, 254, 255, 5, 70, 0, 0, 255, 257, 5, 54, 0, 0, 256, 258, 3,
		130, 65, 0, 257, 256, 1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 259, 1, 0,
		0, 0, 259, 262, 5, 55, 0, 0, 260, 261, 5, 5, 0, 0, 261, 263, 3, 162, 81,
		0, 262, 260, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 270, 1, 0, 0, 0, 264,
		267, 5, 70, 0, 0, 265, 266, 5, 5, 0, 0, 266, 268, 3, 162, 81, 0, 267, 265,
		1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 270, 1, 0, 0, 0, 269, 254, 1, 0,
		0, 0, 269, 264, 1, 0, 0, 0, 270, 15, 1, 0, 0, 0, 271, 272, 5, 11, 0, 0,
		272, 273, 3, 164, 82, 0, 273, 17, 1, 0, 0, 0, 274, 276, 5, 12, 0, 0, 275,
		277, 7, 0, 0, 0, 276, 275, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277, 278,
		1, 0, 0, 0, 278, 279, 3, 164, 82, 0, 279, 19, 1, 0, 0, 0, 280, 281, 5,
		13, 0, 0, 281, 286, 3, 22, 11, 0, 282, 283, 5, 58, 0, 0, 283, 285, 3, 22,
		11, 0, 284, 282, 1, 0, 0, 0, 285, 288, 1, 0, 0, 0, 286, 284, 1, 0, 0, 0,
		286, 287, 1, 0, 0, 0, 287, 21, 1, 0, 0, 0, 288, 286, 1, 0, 0, 0, 289, 290,
		3, 162, 81, 0, 290, 293, 5, 5, 0, 0, 291, 294, 3, 162, 81, 0, 292, 294,
		5, 65, 0, 0, 293, 291, 1, 0, 0, 0, 293, 292, 1, 0, 0, 0, 294, 23, 1, 0,
		0, 0, 295, 299, 5, 14, 0, 0, 296, 298, 3, 26, 13, 0, 297, 296, 1, 0, 0,
		0, 298, 301, 1, 0, 0, 0, 299, 297, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300,
		307, 1, 0, 0, 0, 301, 299, 1, 0, 0, 0, 302, 308, 5, 65, 0, 0, 303, 304,
		3, 162, 81, 0, 304, 305, 5, 44, 0, 0, 305, 306, 5, 65, 0, 0, 306, 308,
		1, 0, 0, 0, 307, 302, 1, 0, 0, 0, 307, 303, 1, 0, 0, 0, 307, 308, 1, 0,
		0, 0, 308, 25, 1, 0, 0, 0, 309, 310, 5, 70, 0, 0, 310, 314, 5, 44, 0, 0,
		311, 315, 5, 65, 0, 0, 312, 315, 3, 162, 81, 0, 313, 315, 5, 67, 0, 0,
		314, 311, 1, 0, 0, 0, 314, 312, 1, 0, 0, 0, 314, 313, 1, 0, 0, 0, 315,
		27, 1, 0, 0, 0, 316, 318, 5, 15, 0, 0, 317, 319, 5, 67, 0, 0, 318, 317,
		1, 0, 0, 0, 318, 319, 1, 0, 0, 0, 319, 320, 1, 0, 0, 0, 320, 324, 3, 164,
		82, 0, 321, 323, 3, 30, 15, 0, 322, 321, 1, 0, 0, 0, 323, 326, 1, 0, 0,
		0, 324, 322, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 29, 1, 0, 0, 0, 326,
		324, 1, 0, 0, 0, 327, 328, 5, 70, 0, 0, 328, 332, 5, 44, 0, 0, 329, 333,
		5, 65, 0, 0, 330, 333, 3, 162, 81, 0, 331, 333, 5, 67, 0, 0, 332, 329,
		1, 0, 0, 0, 332, 330, 1, 0, 0, 0, 332, 331, 1, 0, 0, 0, 333, 31, 1, 0,
		0, 0, 334, 336, 5, 16, 0, 0, 335, 337, 5, 67, 0, 0, 336, 335, 1, 0, 0,
		0, 336, 337, 1, 0, 0, 0, 337, 338, 1, 0, 0, 0, 338, 343, 3, 34, 17, 0,
		339, 340, 5, 58, 0, 0, 340, 342, 3, 34, 17, 0, 341, 339, 1, 0, 0, 0, 342,
		345, 1, 0, 0, 0, 343, 341, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 33, 1,
		0, 0, 0, 345, 343, 1, 0, 0, 0, 346, 348, 7, 0, 0, 0, 347, 346, 1, 0, 0,
		0, 347, 348, 1, 0, 0, 0, 348, 349, 1, 0, 0, 0, 349, 350, 3, 162, 81, 0,
		350, 35, 1, 0, 0, 0, 351, 353, 5, 17, 0, 0, 352, 354, 5, 67, 0, 0, 353,
		352, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 37, 1, 0, 0, 0, 355, 357, 5,
		18, 0, 0, 356, 358, 5, 67, 0, 0, 357, 356, 1, 0, 0, 0, 357, 358, 1, 0,
		0, 0, 358, 39, 1, 0, 0, 0, 359, 361, 5, 19, 0, 0, 360, 362, 5, 67, 0, 0,
		361, 360, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 363, 1, 0, 0, 0, 363,
		366, 3, 164, 82, 0, 364, 365, 5, 4, 0, 0, 365, 367, 3, 164, 82, 0, 366,
		364, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 41, 1, 0, 0, 0, 368, 370, 5,
		20, 0, 0, 369, 371, 5, 67, 0, 0, 370, 369, 1, 0, 0, 0, 370, 371, 1, 0,
		0, 0, 371, 372, 1, 0, 0, 0, 372, 375, 3, 164, 82, 0, 373, 374, 5, 4, 0,
		0, 374, 376, 3, 164, 82, 0, 375, 373, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0,
		376, 43, 1, 0, 0, 0, 377, 381, 5, 21, 0, 0, 378, 380, 3, 46, 23, 0, 379,
		378, 1, 0, 0, 0, 380, 383, 1, 0, 0, 0, 381, 379, 1, 0, 0, 0, 381, 382,
		1, 0, 0, 0, 382, 384, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 384, 385, 5, 70,
		0, 0, 385, 386, 3, 164, 82, 0, 386, 45, 1, 0, 0, 0, 387, 388, 5, 70, 0,
		0, 388, 392, 5, 44, 0, 0, 389, 393, 5, 65, 0, 0, 390, 393, 3, 162, 81,
		0, 391, 393, 5, 67, 0, 0, 392, 389, 1, 0, 0, 0, 392, 390, 1, 0, 0, 0, 392,
		391, 1, 0, 0, 0, 393, 47, 1, 0, 0, 0, 394, 398, 5, 22, 0, 0, 395, 397,
		3, 50, 25, 0, 396, 395, 1, 0, 0, 0, 397, 400, 1, 0, 0, 0, 398, 396, 1,
		0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 401, 1, 0, 0, 0, 400, 398, 1, 0, 0,
		0, 401, 413, 3, 118, 59, 0, 402, 406, 5, 22, 0, 0, 403, 405, 3, 50, 25,
		0, 404, 403, 1, 0, 0, 0, 405, 408, 1, 0, 0, 0, 406, 404, 1, 0, 0, 0, 406,
		407, 1, 0, 0, 0, 407, 409, 1, 0, 0, 0, 408, 406, 1, 0, 0, 0, 409, 410,
		3, 164, 82, 0, 410, 411, 3, 118, 59, 0, 411, 413, 1, 0, 0, 0, 412, 394,
		1, 0, 0, 0, 412, 402, 1, 0, 0, 0, 413, 49, 1, 0, 0, 0, 414, 415, 5, 70,
		0, 0, 415, 419, 5, 44, 0, 0, 416, 420, 5, 65, 0, 0, 417, 420, 3, 162, 81,
		0, 418, 420, 5, 67, 0, 0, 419, 416, 1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 419,
		418, 1, 0, 0, 0, 420, 51, 1, 0, 0, 0, 421, 422, 5, 23, 0, 0, 422, 423,
		3, 118, 59, 0, 423, 53, 1, 0, 0, 0, 424, 425, 5, 24, 0, 0, 425, 429, 3,
		164, 82, 0, 426, 428, 3, 56, 28, 0, 427, 426, 1, 0, 0, 0, 428, 431, 1,
		0, 0, 0, 429, 427, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 55, 1, 0, 0,
		0, 431, 429, 1, 0, 0, 0, 432, 433, 5, 70, 0, 0, 433, 438, 5, 44, 0, 0,
		434, 439, 5, 65, 0, 0, 435, 439, 3, 162, 81, 0, 436, 439, 5, 67, 0, 0,
		437, 439, 5, 66, 0, 0, 438, 434, 1, 0, 0, 0, 438, 435, 1, 0, 0, 0, 438,
		436, 1, 0, 0, 0, 438, 437, 1, 0, 0, 0, 439, 57, 1, 0, 0, 0, 440, 444, 5,
		25, 0, 0, 441, 443, 3, 60, 30, 0, 442, 441, 1, 0, 0, 0, 443, 446, 1, 0,
		0, 0, 444, 442, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 59, 1, 0, 0, 0,
		446, 444, 1, 0, 0, 0, 447, 448, 5, 70, 0, 0, 448, 451, 5, 44, 0, 0, 449,
		452, 5, 65, 0, 0, 450, 452, 3, 162, 81, 0, 451, 449, 1, 0, 0, 0, 451, 450,
		1, 0, 0, 0, 452, 61, 1, 0, 0, 0, 453, 454, 5, 26, 0, 0, 454, 459, 3, 14,
		7, 0, 455, 456, 5, 58, 0, 0, 456, 458, 3, 14, 7, 0, 457, 455, 1, 0, 0,
		0, 458, 461, 1, 0, 0, 0, 459, 457, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460,
		464, 1, 0, 0, 0, 461, 459, 1, 0, 0, 0, 462, 463, 5, 4, 0, 0, 463, 465,
		3, 164, 82, 0, 464, 462, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 63, 1,
		0, 0, 0, 466, 467, 5, 27, 0, 0, 467, 472, 3, 14, 7, 0, 468, 469, 5, 58,
		0, 0, 469, 471, 3, 14, 7, 0, 470, 468, 1, 0, 0, 0, 471, 474, 1, 0, 0, 0,
		472, 470, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 477, 1, 0, 0, 0, 474,
		472, 1, 0, 0, 0, 475, 476, 5, 4, 0, 0, 476, 478, 3, 164, 82, 0, 477, 475,
		1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 65, 1, 0, 0, 0, 479, 483, 5, 28,
		0, 0, 480, 482, 3, 68, 34, 0, 481, 480, 1, 0, 0, 0, 482, 485, 1, 0, 0,
		0, 483, 481, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 486, 1, 0, 0, 0, 485,
		483, 1, 0, 0, 0, 486, 489, 3, 14, 7, 0, 487, 488, 5, 4, 0, 0, 488, 490,
		3, 162, 81, 0, 489, 487, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 67, 1,
		0, 0, 0, 491, 492, 5, 70, 0, 0, 492, 497, 5, 44, 0, 0, 493, 498, 5, 65,
		0, 0, 494, 498, 3, 162, 81, 0, 495, 498, 5, 67, 0, 0, 496, 498, 5, 66,
		0, 0, 497, 493, 1, 0, 0, 0, 497, 494, 1, 0, 0, 0, 497, 495, 1, 0, 0, 0,
		497, 496, 1, 0, 0, 0, 498, 69, 1, 0, 0, 0, 499, 500, 5, 29, 0, 0, 500,
		503, 3, 14, 7, 0, 501, 502, 5, 4, 0, 0, 502, 504, 3, 164, 82, 0, 503, 501,
		1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 507, 1, 0, 0, 0, 505, 506, 5, 37,
		0, 0, 506, 508, 3, 162, 81, 0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0, 0,
		0, 508, 71, 1, 0, 0, 0, 509, 513, 5, 30, 0, 0, 510, 512, 3, 74, 37, 0,
		511, 510, 1, 0, 0, 0, 512, 515, 1, 0, 0, 0, 513, 511, 1, 0, 0, 0, 513,
		514, 1, 0, 0, 0, 514, 517, 1, 0, 0, 0, 515, 513, 1, 0, 0, 0, 516, 518,
		3, 164, 82, 0, 517, 516, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 73, 1,
		0, 0, 0, 519, 520, 5, 70, 0, 0, 520, 521, 5, 44, 0, 0, 521, 522, 7, 1,
		0, 0, 522, 75, 1, 0, 0, 0, 523, 527, 5, 31, 0, 0, 524, 526, 3, 78, 39,
		0, 525, 524, 1, 0, 0, 0, 526, 529, 1, 0, 0, 0, 527, 525, 1, 0, 0, 0, 527,
		528, 1, 0, 0, 0, 528, 530, 1, 0, 0, 0, 529, 527, 1, 0, 0, 0, 530, 531,
		3, 162, 81, 0, 531, 77, 1, 0, 0, 0, 532, 533, 5, 70, 0, 0, 533, 537, 5,
		44, 0, 0, 534, 538, 5, 65, 0, 0, 535, 538, 3, 162, 81, 0, 536, 538, 5,
		67, 0, 0, 537, 534, 1, 0, 0, 0, 537, 535, 1, 0, 0, 0, 537, 536, 1, 0, 0,
		0, 538, 79, 1, 0, 0, 0, 539, 540, 5, 32, 0, 0, 540, 541, 3, 162, 81, 0,
		541, 81, 1, 0, 0, 0, 542, 546, 5, 33, 0, 0, 543, 545, 3, 84, 42, 0, 544,
		543, 1, 0, 0, 0, 545, 548, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546, 547,
		1, 0, 0, 0, 547, 83, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 549, 550, 5, 70,
		0, 0, 550, 551, 5, 44, 0, 0, 551, 552, 7, 1, 0, 0, 552, 85, 1, 0, 0, 0,
		553, 557, 5, 34, 0, 0, 554, 556, 3, 88, 44, 0, 555, 554, 1, 0, 0, 0, 556,
		559, 1, 0, 0, 0, 557, 555, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558, 560,
		1, 0, 0, 0, 559, 557, 1, 0, 0, 0, 560, 565, 3, 90, 45, 0, 561, 562, 5,
		58, 0, 0, 562, 564, 3, 90, 45, 0, 563, 561, 1, 0, 0, 0, 564, 567, 1, 0,
		0, 0, 565, 563, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 87, 1, 0, 0, 0,
		567, 565, 1, 0, 0, 0, 568, 569, 5, 70, 0, 0, 569, 570, 5, 44, 0, 0, 570,
		571, 7, 2, 0, 0, 571, 89, 1, 0, 0, 0, 572, 573, 5, 70, 0, 0, 573, 574,
		5, 54, 0, 0, 574, 575, 3, 162, 81, 0, 575, 581, 5, 55, 0, 0, 576, 579,
		5, 5, 0, 0, 577, 580, 3, 162, 81, 0, 578, 580, 5, 65, 0, 0, 579, 577, 1,
		0, 0, 0, 579, 578, 1, 0, 0, 0, 580, 582, 1, 0, 0, 0, 581, 576, 1, 0, 0,
		0, 581, 582, 1, 0, 0, 0, 582, 91, 1, 0, 0, 0, 583, 584, 7, 3, 0, 0, 584,
		588, 3, 162, 81, 0, 585, 587, 3, 94, 47, 0, 586, 585, 1, 0, 0, 0, 587,
		590, 1, 0, 0, 0, 588, 586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 93, 1,
		0, 0, 0, 590, 588, 1, 0, 0, 0, 591, 592, 5, 70, 0, 0, 592, 593, 5, 44,
		0, 0, 593, 594, 7, 4, 0, 0, 594, 95, 1, 0, 0, 0, 595, 599, 5, 38, 0, 0,
		596, 598, 3, 98, 49, 0, 597, 596, 1, 0, 0, 0, 598, 601, 1, 0, 0, 0, 599,
		597, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 97, 1, 0, 0, 0, 601, 599, 1,
		0, 0, 0, 602, 603, 5, 70, 0, 0, 603, 605, 5, 44, 0, 0, 604, 606, 5, 62,
		0, 0, 605, 604, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 609, 1, 0, 0, 0,
		607, 610, 3, 152, 76, 0, 608, 610, 5, 70, 0, 0, 609, 607, 1, 0, 0, 0, 609,
		608, 1, 0, 0, 0, 610, 614, 1, 0, 0, 0, 611, 614, 5, 72, 0, 0, 612, 614,
		5, 70, 0, 0, 613, 602, 1, 0, 0, 0, 613, 611, 1, 0, 0, 0, 613, 612, 1, 0,
		0, 0, 614, 99, 1, 0, 0, 0, 615, 619, 5, 39, 0, 0, 616, 618, 3, 102, 51,
		0, 617, 616, 1, 0, 0, 0, 618, 621, 1, 0, 0, 0, 619, 617, 1, 0, 0, 0, 619,
		620, 1, 0, 0, 0, 620, 622, 1, 0, 0, 0, 621, 619, 1, 0, 0, 0, 622, 629,
		3, 14, 7, 0, 623, 625, 5, 58, 0, 0, 624, 623, 1, 0, 0, 0, 624, 625, 1,
		0, 0, 0, 625, 626, 1, 0, 0, 0, 626, 628, 3, 14, 7, 0, 627, 624, 1, 0, 0,
		0, 628, 631, 1, 0, 0, 0, 629, 627, 1, 0, 0, 0, 629, 630, 1, 0, 0, 0, 630,
		634, 1, 0, 0, 0, 631, 629, 1, 0, 0, 0, 632, 633, 5, 40, 0, 0, 633, 635,
		3, 104, 52, 0, 634, 632, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 638, 1,
		0, 0, 0, 636, 637, 5, 7, 0, 0, 637, 639, 3, 120, 60, 0, 638, 636, 1, 0,
		0, 0, 638, 639, 1, 0, 0, 0, 639, 647, 1, 0, 0, 0, 640, 643, 7, 5, 0, 0,
		641, 644, 3, 106, 53, 0, 642, 644, 3, 166, 83, 0, 643, 641, 1, 0, 0, 0,
		643, 642, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 643, 1, 0, 0, 0, 645,
		646, 1, 0, 0, 0, 646, 648, 1, 0, 0, 0, 647, 640, 1, 0, 0, 0, 647, 648,
		1, 0, 0, 0, 648, 101, 1, 0, 0, 0, 649, 650, 5, 70, 0, 0, 650, 655, 5, 44,
		0, 0, 651, 656, 5, 65, 0, 0, 652, 656, 3, 162, 81, 0, 653, 656, 5, 67,
		0, 0, 654, 656, 5, 66, 0, 0, 655, 651, 1, 0, 0, 0, 655, 652, 1, 0, 0, 0,
		655, 653, 1, 0, 0, 0, 655, 654, 1, 0, 0, 0, 656, 659, 1, 0, 0, 0, 657,
		659, 5, 73, 0, 0, 658, 649, 1, 0, 0, 0, 658, 657, 1, 0, 0, 0, 659, 103,
		1, 0, 0, 0, 660, 661, 5, 70, 0, 0, 661, 662, 5, 44, 0, 0, 662, 667, 5,
		70, 0, 0, 663, 664, 5, 71, 0, 0, 664, 666, 5, 70, 0, 0, 665, 663, 1, 0,
		0, 0, 666, 669, 1, 0, 0, 0, 667, 665, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0,
		668, 679, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0, 670, 675, 5, 70, 0, 0, 671,
		672, 5, 71, 0, 0, 672, 674, 5, 70, 0, 0, 673, 671, 1, 0, 0, 0, 674, 677,
		1, 0, 0, 0, 675, 673, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 679, 1, 0,
		0, 0, 677, 675, 1, 0, 0, 0, 678, 660, 1, 0, 0, 0, 678, 670, 1, 0, 0, 0,
		679, 105, 1, 0, 0, 0, 680, 681, 5, 70, 0, 0, 681, 686, 5, 44, 0, 0, 682,
		687, 5, 65, 0, 0, 683, 687, 3, 162, 81, 0, 684, 687, 5, 67, 0, 0, 685,
		687, 5, 66, 0, 0, 686, 682, 1, 0, 0, 0, 686, 683, 1, 0, 0, 0, 686, 684,
		1, 0, 0, 0, 686, 685, 1, 0, 0, 0, 687, 107, 1, 0, 0, 0, 688, 692, 5, 42,
		0, 0, 689, 691, 3, 102, 51, 0, 690, 689, 1, 0, 0, 0, 691, 694, 1, 0, 0,
		0, 692, 690, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 695, 1, 0, 0, 0, 694,
		692, 1, 0, 0, 0, 695, 702, 3, 14, 7, 0, 696, 698, 5, 58, 0, 0, 697, 696,
		1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 701, 3, 14,
		7, 0, 700, 697, 1, 0, 0, 0, 701, 704, 1, 0, 0, 0, 702, 700, 1, 0, 0, 0,
		702, 703, 1, 0, 0, 0, 703, 707, 1, 0, 0, 0, 704, 702, 1, 0, 0, 0, 705,
		706, 5, 7, 0, 0, 706, 708, 3, 120, 60, 0, 707, 705, 1, 0, 0, 0, 707, 708,
		1, 0, 0, 0, 708, 716, 1, 0, 0, 0, 709, 712, 7, 5, 0, 0, 710, 713, 3, 106,
		53, 0, 711, 713, 3, 166, 83, 0, 712, 710, 1, 0, 0, 0, 712, 711, 1, 0, 0,
		0, 713, 714, 1, 0, 0, 0, 714, 712, 1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715,
		717, 1, 0, 0, 0, 716, 709, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 109,
		1, 0, 0, 0, 718, 722, 5, 43, 0, 0, 719, 721, 3, 112, 56, 0, 720, 719, 1,
		0, 0, 0, 721, 724, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 722, 723, 1, 0, 0,
		0, 723, 725, 1, 0, 0, 0, 724, 722, 1, 0, 0, 0, 725, 728, 7, 6, 0, 0, 726,
		727, 5, 7, 0, 0, 727, 729, 3, 130, 65, 0, 728, 726, 1, 0, 0, 0, 728, 729,
		1, 0, 0, 0, 729, 111, 1, 0, 0, 0, 730, 731, 5, 70, 0, 0, 731, 735, 5, 44,
		0, 0, 732, 736, 5, 65, 0, 0, 733, 736, 3, 162, 81, 0, 734, 736, 5, 67,
		0, 0, 735, 732, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 735, 734, 1, 0, 0, 0,
		736, 113, 1, 0, 0, 0, 737, 741, 5, 70, 0, 0, 738, 740, 3, 116, 58, 0, 739,
		738, 1, 0, 0, 0, 740, 743, 1, 0, 0, 0, 741, 739, 1, 0, 0, 0, 741, 742,
		1, 0, 0, 0, 742, 115, 1, 0, 0, 0, 743, 741, 1, 0, 0, 0, 744, 753, 5, 70,
		0, 0, 745, 747, 5, 44, 0, 0, 746, 748, 5, 62, 0, 0, 747, 746, 1, 0, 0,
		0, 747, 748, 1, 0, 0, 0, 748, 751, 1, 0, 0, 0, 749, 752, 3, 152, 76, 0,
		750, 752, 5, 70, 0, 0, 751, 749, 1, 0, 0, 0, 751, 750, 1, 0, 0, 0, 752,
		754, 1, 0, 0, 0, 753, 745, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 768,
		1, 0, 0, 0, 755, 757, 5, 62, 0, 0, 756, 755, 1, 0, 0, 0, 756, 757, 1, 0,
		0, 0, 757, 758, 1, 0, 0, 0, 758, 768, 3, 152, 76, 0, 759, 763, 5, 54, 0,
		0, 760, 762, 3, 116, 58, 0, 761, 760, 1, 0, 0, 0, 762, 765, 1, 0, 0, 0,
		763, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 766, 1, 0, 0, 0, 765,
		763, 1, 0, 0, 0, 766, 768, 5, 55, 0, 0, 767, 744, 1, 0, 0, 0, 767, 756,
		1, 0, 0, 0, 767, 759, 1, 0, 0, 0, 768, 117, 1, 0, 0, 0, 769, 770, 5, 56,
		0, 0, 770, 771, 3, 0, 0, 0, 771, 772, 5, 57, 0, 0, 772, 119, 1, 0, 0, 0,
		773, 780, 3, 122, 61, 0, 774, 776, 3, 128, 64, 0, 775, 774, 1, 0, 0, 0,
		775, 776, 1, 0, 0, 0, 776, 777, 1, 0, 0, 0, 777, 779, 3, 122, 61, 0, 778,
		775, 1, 0, 0, 0, 779, 782, 1, 0, 0, 0, 780, 778, 1, 0, 0, 0, 780, 781,
		1, 0, 0, 0, 781, 121, 1, 0, 0, 0, 782, 780, 1, 0, 0, 0, 783, 784, 5, 3,
		0, 0, 784, 794, 3, 122, 61, 0, 785, 786, 5, 54, 0, 0, 786, 787, 3, 120,
		60, 0, 787, 788, 5, 55, 0, 0, 788, 794, 1, 0, 0, 0, 789, 794, 3, 124, 62,
		0, 790, 794, 3, 118, 59, 0, 791, 794, 5, 73, 0, 0, 792, 794, 3, 160, 80,
		0, 793, 783, 1, 0, 0, 0, 793, 785, 1, 0, 0, 0, 793, 789, 1, 0, 0, 0, 793,
		790, 1, 0, 0, 0, 793, 791, 1, 0, 0, 0, 793, 792, 1, 0, 0, 0, 794, 123,
		1, 0, 0, 0, 795, 796, 3, 162, 81, 0, 796, 797, 3, 126, 63, 0, 797, 798,
		3, 152, 76, 0, 798, 811, 1, 0, 0, 0, 799, 800, 3, 162, 81, 0, 800, 801,
		5, 6, 0, 0, 801, 802, 5, 54, 0, 0, 802, 803, 3, 168, 84, 0, 803, 804, 5,
		55, 0, 0, 804, 811, 1, 0, 0, 0, 805, 806, 3, 162, 81, 0, 806, 807, 5, 6,
		0, 0, 807, 808, 3, 118, 59, 0, 808, 811, 1, 0, 0, 0, 809, 811, 3, 148,
		74, 0, 810, 795, 1, 0, 0, 0, 810, 799, 1, 0, 0, 0, 810, 805, 1, 0, 0, 0,
		810, 809, 1, 0, 0, 0, 811, 125, 1, 0, 0, 0, 812, 813, 7, 7, 0, 0, 813,
		127, 1, 0, 0, 0, 814, 815, 7, 8, 0, 0, 815, 129, 1, 0, 0, 0, 816, 817,
		3, 132, 66, 0, 817, 131, 1, 0, 0, 0, 818, 823, 3, 134, 67, 0, 819, 820,
		5, 2, 0, 0, 820, 822, 3, 134, 67, 0, 821, 819, 1, 0, 0, 0, 822, 825, 1,
		0, 0, 0, 823, 821, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0, 824, 133, 1, 0, 0,
		0, 825, 823, 1, 0, 0, 0, 826, 833, 3, 136, 68, 0, 827, 829, 5, 1, 0, 0,
		828, 827, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 830, 1, 0, 0, 0, 830,
		832, 3, 136, 68, 0, 831, 828, 1, 0, 0, 0, 832, 835, 1, 0, 0, 0, 833, 831,
		1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 135, 1, 0, 0, 0, 835, 833, 1, 0,
		0, 0, 836, 837, 5, 3, 0, 0, 837, 840, 3, 136, 68, 0, 838, 840, 3, 138,
		69, 0, 839, 836, 1, 0, 0, 0, 839, 838, 1, 0, 0, 0, 840, 137, 1, 0, 0, 0,
		841, 849, 3, 124, 62, 0, 842, 846, 3, 140, 70, 0, 843, 844, 3, 126, 63,
		0, 844, 845, 3, 140, 70, 0, 845, 847, 1, 0, 0, 0, 846, 843, 1, 0, 0, 0,
		846, 847, 1, 0, 0, 0, 847, 849, 1, 0, 0, 0, 848, 841, 1, 0, 0, 0, 848,
		842, 1, 0, 0, 0, 849, 139, 1, 0, 0, 0, 850, 855, 3, 142, 71, 0, 851, 852,
		7, 9, 0, 0, 852, 854, 3, 142, 71, 0, 853, 851, 1, 0, 0, 0, 854, 857, 1,
		0, 0, 0, 855, 853, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 141, 1, 0, 0,
		0, 857, 855, 1, 0, 0, 0, 858, 863, 3, 144, 72, 0, 859, 860, 7, 10, 0, 0,
		860, 862, 3, 144, 72, 0, 861, 859, 1, 0, 0, 0, 862, 865, 1, 0, 0, 0, 863,
		861, 1, 0, 0, 0, 863, 864, 1, 0, 0, 0, 864, 143, 1, 0, 0, 0, 865, 863,
		1, 0, 0, 0, 866, 867, 5, 62, 0, 0, 867, 870, 3, 144, 72, 0, 868, 870, 3,
		146, 73, 0, 869, 866, 1, 0, 0, 0, 869, 868, 1, 0, 0, 0, 870, 145, 1, 0,
		0, 0, 871, 872, 5, 54, 0, 0, 872, 873, 3, 130, 65, 0, 873, 874, 5, 55,
		0, 0, 874, 880, 1, 0, 0, 0, 875, 880, 3, 118, 59, 0, 876, 880, 3, 148,
		74, 0, 877, 880, 3, 152, 76, 0, 878, 880, 3, 162, 81, 0, 879, 871, 1, 0,
		0, 0, 879, 875, 1, 0, 0, 0, 879, 876, 1, 0, 0, 0, 879, 877, 1, 0, 0, 0,
		879, 878, 1, 0, 0, 0, 880, 147, 1, 0, 0, 0, 881, 882, 5, 70, 0, 0, 882,
		884, 5, 54, 0, 0, 883, 885, 3, 150, 75, 0, 884, 883, 1, 0, 0, 0, 884, 885,
		1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 909, 5, 55, 0, 0, 887, 888, 5, 9,
		0, 0, 888, 890, 5, 54, 0, 0, 889, 891, 3, 150, 75, 0, 890, 889, 1, 0, 0,
		0, 890, 891, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 909, 5, 55, 0, 0, 893,
		894, 5, 51, 0, 0, 894, 895, 5, 54, 0, 0, 895, 896, 3, 150, 75, 0, 896,
		897, 5, 55, 0, 0, 897, 909, 1, 0, 0, 0, 898, 899, 5, 50, 0, 0, 899, 900,
		5, 54, 0, 0, 900, 901, 3, 150, 75, 0, 901, 902, 5, 55, 0, 0, 902, 909,
		1, 0, 0, 0, 903, 904, 5, 52, 0, 0, 904, 905, 5, 54, 0, 0, 905, 906, 3,
		150, 75, 0, 906, 907, 5, 55, 0, 0, 907, 909, 1, 0, 0, 0, 908, 881, 1, 0,
		0, 0, 908, 887, 1, 0, 0, 0, 908, 893, 1, 0, 0, 0, 908, 898, 1, 0, 0, 0,
		908, 903, 1, 0, 0, 0, 909, 149, 1, 0, 0, 0, 910, 915, 3, 130, 65, 0, 911,
		912, 5, 58, 0, 0, 912, 914, 3, 130, 65, 0, 913, 911, 1, 0, 0, 0, 914, 917,
		1, 0, 0, 0, 915, 913, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 151, 1, 0,
		0, 0, 917, 915, 1, 0, 0, 0, 918, 925, 5, 65, 0, 0, 919, 925, 5, 67, 0,
		0, 920, 925, 5, 66, 0, 0, 921, 925, 3, 158, 79, 0, 922, 925, 3, 154, 77,
		0, 923, 925, 5, 70, 0, 0, 924, 918, 1, 0, 0, 0, 924, 919, 1, 0, 0, 0, 924,
		920, 1, 0, 0, 0, 924, 921, 1, 0, 0, 0, 924, 922, 1, 0, 0, 0, 924, 923,
		1, 0, 0, 0, 925, 153, 1, 0, 0, 0, 926, 929, 3, 156, 78, 0, 927, 928, 5,
		59, 0, 0, 928, 930, 3, 156, 78, 0, 929, 927, 1, 0, 0, 0, 930, 931, 1, 0,
		0, 0, 931, 929, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 155, 1, 0, 0, 0,
		933, 938, 5, 70, 0, 0, 934, 935, 7, 11, 0, 0, 935, 937, 5, 70, 0, 0, 936,
		934, 1, 0, 0, 0, 937, 940, 1, 0, 0, 0, 938, 936, 1, 0, 0, 0, 938, 939,
		1, 0, 0, 0, 939, 157, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 941, 942, 5, 70,
		0, 0, 942, 943, 5, 68, 0, 0, 943, 958, 5, 69, 0, 0, 944, 945, 5, 70, 0,
		0, 945, 958, 5, 68, 0, 0, 946, 947, 5, 68, 0, 0, 947, 948, 5, 70, 0, 0,
		948, 958, 5, 68, 0, 0, 949, 950, 5, 68, 0, 0, 950, 958, 5, 70, 0, 0, 951,
		952, 5, 68, 0, 0, 952, 953, 5, 71, 0, 0, 953, 958, 5, 70, 0, 0, 954, 955,
		5, 68, 0, 0, 955, 958, 5, 69, 0, 0, 956, 958, 5, 68, 0, 0, 957, 941, 1,
		0, 0, 0, 957, 944, 1, 0, 0, 0, 957, 946, 1, 0, 0, 0, 957, 949, 1, 0, 0,
		0, 957, 951, 1, 0, 0, 0, 957, 954, 1, 0, 0, 0, 957, 956, 1, 0, 0, 0, 958,
		159, 1, 0, 0, 0, 959, 964, 5, 70, 0, 0, 960, 964, 5, 67, 0, 0, 961, 964,
		5, 65, 0, 0, 962, 964, 3, 158, 79, 0, 963, 959, 1, 0, 0, 0, 963, 960, 1,
		0, 0, 0, 963, 961, 1, 0, 0, 0, 963, 962, 1, 0, 0, 0, 964, 161, 1, 0, 0,
		0, 965, 966, 7, 12, 0, 0, 966, 163, 1, 0, 0, 0, 967, 974, 3, 166, 83, 0,
		968, 970, 5, 58, 0, 0, 969, 968, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970,
		971, 1, 0, 0, 0, 971, 973, 3, 166, 83, 0, 972, 969, 1, 0, 0, 0, 973, 976,
		1, 0, 0, 0, 974, 972, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 165, 1, 0,
		0, 0, 976, 974, 1, 0, 0, 0, 977, 980, 3, 162, 81, 0, 978, 980, 5, 65, 0,
		0, 979, 977, 1, 0, 0, 0, 979, 978, 1, 0, 0, 0, 980, 167, 1, 0, 0, 0, 981,
		986, 3, 152, 76, 0, 982, 983, 5, 58, 0, 0, 983, 985, 3, 152, 76, 0, 984,
		982, 1, 0, 0, 0, 985, 988, 1, 0, 0, 0, 986, 984, 1, 0, 0, 0, 986, 987,
		1, 0, 0, 0, 987, 169, 1, 0, 0, 0, 988, 986, 1, 0, 0, 0, 121, 171, 178,
		215, 218, 231, 236, 247, 252, 257, 262, 267, 269, 276, 286, 293, 299, 307,
		314, 318, 324, 332, 336, 343, 347, 353, 357, 361, 366, 370, 375, 381, 392,
		398, 406, 412, 419, 429, 438, 444, 451, 459, 464, 472, 477, 483, 489, 497,
		503, 507, 513, 517, 527, 537, 546, 557, 565, 579, 581, 588, 599, 605, 609,
		613, 619, 624, 629, 634, 638, 643, 645, 647, 655, 658, 667, 675, 678, 686,
		692, 697, 702, 707, 712, 714, 716, 722, 728, 735, 741, 747, 751, 753, 756,
		763, 767, 775, 780, 793, 810, 823, 828, 833, 839, 846, 848, 855, 863, 869,
		879, 884, 890, 908, 915, 924, 931, 938, 957, 963, 969, 974, 979, 986,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SPLParserInit initializes any static state used to implement SPLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSPLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SPLParserInit() {
	staticData := &SPLParserParserStaticData
	staticData.once.Do(splparserParserInit)
}

// NewSPLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSPLParser(input antlr.TokenStream) *SPLParser {
	SPLParserInit()
	this := new(SPLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SPLParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SPLParser.g4"

	return this
}

// SPLParser tokens.
const (
	SPLParserEOF           = antlr.TokenEOF
	SPLParserAND           = 1
	SPLParserOR            = 2
	SPLParserNOT           = 3
	SPLParserBY            = 4
	SPLParserAS            = 5
	SPLParserIN            = 6
	SPLParserWHERE         = 7
	SPLParserSEARCH        = 8
	SPLParserEVAL          = 9
	SPLParserSTATS         = 10
	SPLParserTABLE         = 11
	SPLParserFIELDS        = 12
	SPLParserRENAME        = 13
	SPLParserREX           = 14
	SPLParserDEDUP         = 15
	SPLParserSORT          = 16
	SPLParserHEAD          = 17
	SPLParserTAIL          = 18
	SPLParserTOP           = 19
	SPLParserRARE          = 20
	SPLParserLOOKUP        = 21
	SPLParserJOIN          = 22
	SPLParserAPPEND        = 23
	SPLParserTRANSACTION   = 24
	SPLParserSPATH         = 25
	SPLParserEVENTSTATS    = 26
	SPLParserSTREAMSTATS   = 27
	SPLParserTIMECHART     = 28
	SPLParserCHART         = 29
	SPLParserFILLNULL      = 30
	SPLParserMAKEMV        = 31
	SPLParserMVEXPAND      = 32
	SPLParserFORMAT        = 33
	SPLParserCONVERT       = 34
	SPLParserBUCKET        = 35
	SPLParserBIN           = 36
	SPLParserOVER          = 37
	SPLParserREST          = 38
	SPLParserTSTATS        = 39
	SPLParserFROM          = 40
	SPLParserGROUPBY       = 41
	SPLParserMSTATS        = 42
	SPLParserINPUTLOOKUP   = 43
	SPLParserEQ            = 44
	SPLParserNEQ           = 45
	SPLParserLT            = 46
	SPLParserGT            = 47
	SPLParserLTE           = 48
	SPLParserGTE           = 49
	SPLParserLIKE          = 50
	SPLParserMATCH         = 51
	SPLParserCIDRMATCH     = 52
	SPLParserPIPE          = 53
	SPLParserLPAREN        = 54
	SPLParserRPAREN        = 55
	SPLParserLBRACKET      = 56
	SPLParserRBRACKET      = 57
	SPLParserCOMMA         = 58
	SPLParserCOLON         = 59
	SPLParserDQUOTE        = 60
	SPLParserPLUS          = 61
	SPLParserMINUS         = 62
	SPLParserSLASH         = 63
	SPLParserPERCENT       = 64
	SPLParserQUOTED_STRING = 65
	SPLParserTIME_SPAN     = 66
	SPLParserNUMBER        = 67
	SPLParserWILDCARD      = 68
	SPLParserDOLLAR        = 69
	SPLParserIDENTIFIER    = 70
	SPLParserDOT           = 71
	SPLParserREST_PATH     = 72
	SPLParserMACRO         = 73
	SPLParserTIME_MODIFIER = 74
	SPLParserWS            = 75
	SPLParserLINE_COMMENT  = 76
)

// SPLParser rules.
const (
	SPLParserRULE_query                    = 0
	SPLParserRULE_pipelineStage            = 1
	SPLParserRULE_searchCommand            = 2
	SPLParserRULE_whereCommand             = 3
	SPLParserRULE_evalCommand              = 4
	SPLParserRULE_evalAssignment           = 5
	SPLParserRULE_statsCommand             = 6
	SPLParserRULE_statsFunction            = 7
	SPLParserRULE_tableCommand             = 8
	SPLParserRULE_fieldsCommand            = 9
	SPLParserRULE_renameCommand            = 10
	SPLParserRULE_renameSpec               = 11
	SPLParserRULE_rexCommand               = 12
	SPLParserRULE_rexOption                = 13
	SPLParserRULE_dedupCommand             = 14
	SPLParserRULE_dedupOption              = 15
	SPLParserRULE_sortCommand              = 16
	SPLParserRULE_sortField                = 17
	SPLParserRULE_headCommand              = 18
	SPLParserRULE_tailCommand              = 19
	SPLParserRULE_topCommand               = 20
	SPLParserRULE_rareCommand              = 21
	SPLParserRULE_lookupCommand            = 22
	SPLParserRULE_lookupOption             = 23
	SPLParserRULE_joinCommand              = 24
	SPLParserRULE_joinOption               = 25
	SPLParserRULE_appendCommand            = 26
	SPLParserRULE_transactionCommand       = 27
	SPLParserRULE_transactionOption        = 28
	SPLParserRULE_spathCommand             = 29
	SPLParserRULE_spathOption              = 30
	SPLParserRULE_eventstatsCommand        = 31
	SPLParserRULE_streamstatsCommand       = 32
	SPLParserRULE_timechartCommand         = 33
	SPLParserRULE_timechartOption          = 34
	SPLParserRULE_chartCommand             = 35
	SPLParserRULE_fillnullCommand          = 36
	SPLParserRULE_fillnullOption           = 37
	SPLParserRULE_makemvCommand            = 38
	SPLParserRULE_makemvOption             = 39
	SPLParserRULE_mvexpandCommand          = 40
	SPLParserRULE_formatCommand            = 41
	SPLParserRULE_formatOption             = 42
	SPLParserRULE_convertCommand           = 43
	SPLParserRULE_convertOption            = 44
	SPLParserRULE_convertFunction          = 45
	SPLParserRULE_bucketCommand            = 46
	SPLParserRULE_bucketOption             = 47
	SPLParserRULE_restCommand              = 48
	SPLParserRULE_restArg                  = 49
	SPLParserRULE_tstatsCommand            = 50
	SPLParserRULE_tstatsPreOption          = 51
	SPLParserRULE_tstatsDatamodel          = 52
	SPLParserRULE_tstatsPostOption         = 53
	SPLParserRULE_mstatsCommand            = 54
	SPLParserRULE_inputlookupCommand       = 55
	SPLParserRULE_inputlookupOption        = 56
	SPLParserRULE_genericCommand           = 57
	SPLParserRULE_genericArg               = 58
	SPLParserRULE_subsearch                = 59
	SPLParserRULE_searchExpression         = 60
	SPLParserRULE_searchTerm               = 61
	SPLParserRULE_condition                = 62
	SPLParserRULE_comparisonOp             = 63
	SPLParserRULE_logicalOp                = 64
	SPLParserRULE_expression               = 65
	SPLParserRULE_orExpression             = 66
	SPLParserRULE_andExpression            = 67
	SPLParserRULE_notExpression            = 68
	SPLParserRULE_comparisonExpression     = 69
	SPLParserRULE_additiveExpression       = 70
	SPLParserRULE_multiplicativeExpression = 71
	SPLParserRULE_unaryExpression          = 72
	SPLParserRULE_primaryExpression        = 73
	SPLParserRULE_functionCall             = 74
	SPLParserRULE_argumentList             = 75
	SPLParserRULE_value                    = 76
	SPLParserRULE_colonValue               = 77
	SPLParserRULE_extendedIdentifier       = 78
	SPLParserRULE_wildcardValue            = 79
	SPLParserRULE_bareWord                 = 80
	SPLParserRULE_fieldName                = 81
	SPLParserRULE_fieldList                = 82
	SPLParserRULE_fieldOrQuoted            = 83
	SPLParserRULE_valueList                = 84
)

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPipelineStage() []IPipelineStageContext
	PipelineStage(i int) IPipelineStageContext
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) AllPipelineStage() []IPipelineStageContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPipelineStageContext); ok {
			len++
		}
	}

	tst := make([]IPipelineStageContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPipelineStageContext); ok {
			tst[i] = t.(IPipelineStageContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) PipelineStage(i int) IPipelineStageContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPipelineStageContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPipelineStageContext)
}

func (s *QueryContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(SPLParserPIPE)
}

func (s *QueryContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserPIPE, i)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SPLParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserPIPE {
		{
			p.SetState(170)
			p.Match(SPLParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(173)
		p.PipelineStage()
	}
	p.SetState(178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserPIPE {
		{
			p.SetState(174)
			p.Match(SPLParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(175)
			p.PipelineStage()
		}

		p.SetState(180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPipelineStageContext is an interface to support dynamic dispatch.
type IPipelineStageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SearchCommand() ISearchCommandContext
	WhereCommand() IWhereCommandContext
	EvalCommand() IEvalCommandContext
	StatsCommand() IStatsCommandContext
	TableCommand() ITableCommandContext
	FieldsCommand() IFieldsCommandContext
	RenameCommand() IRenameCommandContext
	RexCommand() IRexCommandContext
	DedupCommand() IDedupCommandContext
	SortCommand() ISortCommandContext
	HeadCommand() IHeadCommandContext
	TailCommand() ITailCommandContext
	TopCommand() ITopCommandContext
	RareCommand() IRareCommandContext
	LookupCommand() ILookupCommandContext
	JoinCommand() IJoinCommandContext
	AppendCommand() IAppendCommandContext
	TransactionCommand() ITransactionCommandContext
	SpathCommand() ISpathCommandContext
	EventstatsCommand() IEventstatsCommandContext
	StreamstatsCommand() IStreamstatsCommandContext
	TimechartCommand() ITimechartCommandContext
	ChartCommand() IChartCommandContext
	FillnullCommand() IFillnullCommandContext
	MakemvCommand() IMakemvCommandContext
	MvexpandCommand() IMvexpandCommandContext
	FormatCommand() IFormatCommandContext
	ConvertCommand() IConvertCommandContext
	BucketCommand() IBucketCommandContext
	RestCommand() IRestCommandContext
	TstatsCommand() ITstatsCommandContext
	MstatsCommand() IMstatsCommandContext
	InputlookupCommand() IInputlookupCommandContext
	GenericCommand() IGenericCommandContext

	// IsPipelineStageContext differentiates from other interfaces.
	IsPipelineStageContext()
}

type PipelineStageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipelineStageContext() *PipelineStageContext {
	var p = new(PipelineStageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_pipelineStage
	return p
}

func InitEmptyPipelineStageContext(p *PipelineStageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_pipelineStage
}

func (*PipelineStageContext) IsPipelineStageContext() {}

func NewPipelineStageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PipelineStageContext {
	var p = new(PipelineStageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_pipelineStage

	return p
}

func (s *PipelineStageContext) GetParser() antlr.Parser { return s.parser }

func (s *PipelineStageContext) SearchCommand() ISearchCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchCommandContext)
}

func (s *PipelineStageContext) WhereCommand() IWhereCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereCommandContext)
}

func (s *PipelineStageContext) EvalCommand() IEvalCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvalCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvalCommandContext)
}

func (s *PipelineStageContext) StatsCommand() IStatsCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsCommandContext)
}

func (s *PipelineStageContext) TableCommand() ITableCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableCommandContext)
}

func (s *PipelineStageContext) FieldsCommand() IFieldsCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsCommandContext)
}

func (s *PipelineStageContext) RenameCommand() IRenameCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameCommandContext)
}

func (s *PipelineStageContext) RexCommand() IRexCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRexCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRexCommandContext)
}

func (s *PipelineStageContext) DedupCommand() IDedupCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDedupCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDedupCommandContext)
}

func (s *PipelineStageContext) SortCommand() ISortCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortCommandContext)
}

func (s *PipelineStageContext) HeadCommand() IHeadCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHeadCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHeadCommandContext)
}

func (s *PipelineStageContext) TailCommand() ITailCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITailCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITailCommandContext)
}

func (s *PipelineStageContext) TopCommand() ITopCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopCommandContext)
}

func (s *PipelineStageContext) RareCommand() IRareCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRareCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRareCommandContext)
}

func (s *PipelineStageContext) LookupCommand() ILookupCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookupCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookupCommandContext)
}

func (s *PipelineStageContext) JoinCommand() IJoinCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCommandContext)
}

func (s *PipelineStageContext) AppendCommand() IAppendCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAppendCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAppendCommandContext)
}

func (s *PipelineStageContext) TransactionCommand() ITransactionCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCommandContext)
}

func (s *PipelineStageContext) SpathCommand() ISpathCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpathCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpathCommandContext)
}

func (s *PipelineStageContext) EventstatsCommand() IEventstatsCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventstatsCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventstatsCommandContext)
}

func (s *PipelineStageContext) StreamstatsCommand() IStreamstatsCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStreamstatsCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStreamstatsCommandContext)
}

func (s *PipelineStageContext) TimechartCommand() ITimechartCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimechartCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimechartCommandContext)
}

func (s *PipelineStageContext) ChartCommand() IChartCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChartCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChartCommandContext)
}

func (s *PipelineStageContext) FillnullCommand() IFillnullCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFillnullCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFillnullCommandContext)
}

func (s *PipelineStageContext) MakemvCommand() IMakemvCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakemvCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakemvCommandContext)
}

func (s *PipelineStageContext) MvexpandCommand() IMvexpandCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvexpandCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvexpandCommandContext)
}

func (s *PipelineStageContext) FormatCommand() IFormatCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatCommandContext)
}

func (s *PipelineStageContext) ConvertCommand() IConvertCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertCommandContext)
}

func (s *PipelineStageContext) BucketCommand() IBucketCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketCommandContext)
}

func (s *PipelineStageContext) RestCommand() IRestCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestCommandContext)
}

func (s *PipelineStageContext) TstatsCommand() ITstatsCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITstatsCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITstatsCommandContext)
}

func (s *PipelineStageContext) MstatsCommand() IMstatsCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMstatsCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMstatsCommandContext)
}

func (s *PipelineStageContext) InputlookupCommand() IInputlookupCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputlookupCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputlookupCommandContext)
}

func (s *PipelineStageContext) GenericCommand() IGenericCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericCommandContext)
}

func (s *PipelineStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PipelineStageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PipelineStageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterPipelineStage(s)
	}
}

func (s *PipelineStageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitPipelineStage(s)
	}
}

func (s *PipelineStageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitPipelineStage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) PipelineStage() (localctx IPipelineStageContext) {
	localctx = NewPipelineStageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SPLParserRULE_pipelineStage)
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(181)
			p.SearchCommand()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(182)
			p.WhereCommand()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(183)
			p.EvalCommand()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(184)
			p.StatsCommand()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(185)
			p.TableCommand()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(186)
			p.FieldsCommand()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(187)
			p.RenameCommand()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(188)
			p.RexCommand()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(189)
			p.DedupCommand()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(190)
			p.SortCommand()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(191)
			p.HeadCommand()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(192)
			p.TailCommand()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(193)
			p.TopCommand()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(194)
			p.RareCommand()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(195)
			p.LookupCommand()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(196)
			p.JoinCommand()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(197)
			p.AppendCommand()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(198)
			p.TransactionCommand()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(199)
			p.SpathCommand()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(200)
			p.EventstatsCommand()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(201)
			p.StreamstatsCommand()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(202)
			p.TimechartCommand()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(203)
			p.ChartCommand()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(204)
			p.FillnullCommand()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(205)
			p.MakemvCommand()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(206)
			p.MvexpandCommand()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(207)
			p.FormatCommand()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(208)
			p.ConvertCommand()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(209)
			p.BucketCommand()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(210)
			p.RestCommand()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(211)
			p.TstatsCommand()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(212)
			p.MstatsCommand()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(213)
			p.InputlookupCommand()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(214)
			p.GenericCommand()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchCommandContext is an interface to support dynamic dispatch.
type ISearchCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SearchExpression() ISearchExpressionContext
	SEARCH() antlr.TerminalNode

	// IsSearchCommandContext differentiates from other interfaces.
	IsSearchCommandContext()
}

type SearchCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchCommandContext() *SearchCommandContext {
	var p = new(SearchCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_searchCommand
	return p
}

func InitEmptySearchCommandContext(p *SearchCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_searchCommand
}

func (*SearchCommandContext) IsSearchCommandContext() {}

func NewSearchCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchCommandContext {
	var p = new(SearchCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_searchCommand

	return p
}

func (s *SearchCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchCommandContext) SearchExpression() ISearchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchExpressionContext)
}

func (s *SearchCommandContext) SEARCH() antlr.TerminalNode {
	return s.GetToken(SPLParserSEARCH, 0)
}

func (s *SearchCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSearchCommand(s)
	}
}

func (s *SearchCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSearchCommand(s)
	}
}

func (s *SearchCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSearchCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) SearchCommand() (localctx ISearchCommandContext) {
	localctx = NewSearchCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SPLParserRULE_searchCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserSEARCH {
		{
			p.SetState(217)
			p.Match(SPLParserSEARCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(220)
		p.SearchExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereCommandContext is an interface to support dynamic dispatch.
type IWhereCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWhereCommandContext differentiates from other interfaces.
	IsWhereCommandContext()
}

type WhereCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereCommandContext() *WhereCommandContext {
	var p = new(WhereCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_whereCommand
	return p
}

func InitEmptyWhereCommandContext(p *WhereCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_whereCommand
}

func (*WhereCommandContext) IsWhereCommandContext() {}

func NewWhereCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereCommandContext {
	var p = new(WhereCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_whereCommand

	return p
}

func (s *WhereCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereCommandContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SPLParserWHERE, 0)
}

func (s *WhereCommandContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterWhereCommand(s)
	}
}

func (s *WhereCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitWhereCommand(s)
	}
}

func (s *WhereCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitWhereCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) WhereCommand() (localctx IWhereCommandContext) {
	localctx = NewWhereCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SPLParserRULE_whereCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(SPLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(223)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvalCommandContext is an interface to support dynamic dispatch.
type IEvalCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVAL() antlr.TerminalNode
	AllEvalAssignment() []IEvalAssignmentContext
	EvalAssignment(i int) IEvalAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEvalCommandContext differentiates from other interfaces.
	IsEvalCommandContext()
}

type EvalCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvalCommandContext() *EvalCommandContext {
	var p = new(EvalCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_evalCommand
	return p
}

func InitEmptyEvalCommandContext(p *EvalCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_evalCommand
}

func (*EvalCommandContext) IsEvalCommandContext() {}

func NewEvalCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvalCommandContext {
	var p = new(EvalCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_evalCommand

	return p
}

func (s *EvalCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *EvalCommandContext) EVAL() antlr.TerminalNode {
	return s.GetToken(SPLParserEVAL, 0)
}

func (s *EvalCommandContext) AllEvalAssignment() []IEvalAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvalAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IEvalAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvalAssignmentContext); ok {
			tst[i] = t.(IEvalAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *EvalCommandContext) EvalAssignment(i int) IEvalAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvalAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvalAssignmentContext)
}

func (s *EvalCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *EvalCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *EvalCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvalCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvalCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterEvalCommand(s)
	}
}

func (s *EvalCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitEvalCommand(s)
	}
}

func (s *EvalCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitEvalCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) EvalCommand() (localctx IEvalCommandContext) {
	localctx = NewEvalCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SPLParserRULE_evalCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(225)
		p.Match(SPLParserEVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(226)
		p.EvalAssignment()
	}
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(227)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(228)
			p.EvalAssignment()
		}

		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvalAssignmentContext is an interface to support dynamic dispatch.
type IEvalAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	Expression() IExpressionContext
	FieldName() IFieldNameContext
	QUOTED_STRING() antlr.TerminalNode

	// IsEvalAssignmentContext differentiates from other interfaces.
	IsEvalAssignmentContext()
}

type EvalAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvalAssignmentContext() *EvalAssignmentContext {
	var p = new(EvalAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_evalAssignment
	return p
}

func InitEmptyEvalAssignmentContext(p *EvalAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_evalAssignment
}

func (*EvalAssignmentContext) IsEvalAssignmentContext() {}

func NewEvalAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvalAssignmentContext {
	var p = new(EvalAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_evalAssignment

	return p
}

func (s *EvalAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *EvalAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *EvalAssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EvalAssignmentContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *EvalAssignmentContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *EvalAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvalAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvalAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterEvalAssignment(s)
	}
}

func (s *EvalAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitEvalAssignment(s)
	}
}

func (s *EvalAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitEvalAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) EvalAssignment() (localctx IEvalAssignmentContext) {
	localctx = NewEvalAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SPLParserRULE_evalAssignment)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(234)
			p.FieldName()
		}

	case SPLParserQUOTED_STRING:
		{
			p.SetState(235)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(238)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(239)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatsCommandContext is an interface to support dynamic dispatch.
type IStatsCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STATS() antlr.TerminalNode
	AllStatsFunction() []IStatsFunctionContext
	StatsFunction(i int) IStatsFunctionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldList() IFieldListContext

	// IsStatsCommandContext differentiates from other interfaces.
	IsStatsCommandContext()
}

type StatsCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatsCommandContext() *StatsCommandContext {
	var p = new(StatsCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_statsCommand
	return p
}

func InitEmptyStatsCommandContext(p *StatsCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_statsCommand
}

func (*StatsCommandContext) IsStatsCommandContext() {}

func NewStatsCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatsCommandContext {
	var p = new(StatsCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_statsCommand

	return p
}

func (s *StatsCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *StatsCommandContext) STATS() antlr.TerminalNode {
	return s.GetToken(SPLParserSTATS, 0)
}

func (s *StatsCommandContext) AllStatsFunction() []IStatsFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			len++
		}
	}

	tst := make([]IStatsFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatsFunctionContext); ok {
			tst[i] = t.(IStatsFunctionContext)
			i++
		}
	}

	return tst
}

func (s *StatsCommandContext) StatsFunction(i int) IStatsFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsFunctionContext)
}

func (s *StatsCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *StatsCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *StatsCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *StatsCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *StatsCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatsCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatsCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterStatsCommand(s)
	}
}

func (s *StatsCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitStatsCommand(s)
	}
}

func (s *StatsCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitStatsCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) StatsCommand() (localctx IStatsCommandContext) {
	localctx = NewStatsCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SPLParserRULE_statsCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		p.Match(SPLParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(242)
		p.StatsFunction()
	}
	p.SetState(247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(243)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(244)
			p.StatsFunction()
		}

		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY {
		{
			p.SetState(250)
			p.Match(SPLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(251)
			p.FieldList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatsFunctionContext is an interface to support dynamic dispatch.
type IStatsFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	FieldName() IFieldNameContext

	// IsStatsFunctionContext differentiates from other interfaces.
	IsStatsFunctionContext()
}

type StatsFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatsFunctionContext() *StatsFunctionContext {
	var p = new(StatsFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_statsFunction
	return p
}

func InitEmptyStatsFunctionContext(p *StatsFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_statsFunction
}

func (*StatsFunctionContext) IsStatsFunctionContext() {}

func NewStatsFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatsFunctionContext {
	var p = new(StatsFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_statsFunction

	return p
}

func (s *StatsFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatsFunctionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *StatsFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserLPAREN, 0)
}

func (s *StatsFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserRPAREN, 0)
}

func (s *StatsFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatsFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(SPLParserAS, 0)
}

func (s *StatsFunctionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *StatsFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatsFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatsFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterStatsFunction(s)
	}
}

func (s *StatsFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitStatsFunction(s)
	}
}

func (s *StatsFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitStatsFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) StatsFunction() (localctx IStatsFunctionContext) {
	localctx = NewStatsFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SPLParserRULE_statsFunction)
	var _la int

	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(254)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(255)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4709653603973857800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&47) != 0) {
			{
				p.SetState(256)
				p.Expression()
			}

		}
		{
			p.SetState(259)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserAS {
			{
				p.SetState(260)
				p.Match(SPLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(261)
				p.FieldName()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(264)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserAS {
			{
				p.SetState(265)
				p.Match(SPLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(266)
				p.FieldName()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableCommandContext is an interface to support dynamic dispatch.
type ITableCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	FieldList() IFieldListContext

	// IsTableCommandContext differentiates from other interfaces.
	IsTableCommandContext()
}

type TableCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableCommandContext() *TableCommandContext {
	var p = new(TableCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tableCommand
	return p
}

func InitEmptyTableCommandContext(p *TableCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tableCommand
}

func (*TableCommandContext) IsTableCommandContext() {}

func NewTableCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableCommandContext {
	var p = new(TableCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_tableCommand

	return p
}

func (s *TableCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *TableCommandContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SPLParserTABLE, 0)
}

func (s *TableCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *TableCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTableCommand(s)
	}
}

func (s *TableCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTableCommand(s)
	}
}

func (s *TableCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTableCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TableCommand() (localctx ITableCommandContext) {
	localctx = NewTableCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SPLParserRULE_tableCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(271)
		p.Match(SPLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(272)
		p.FieldList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldsCommandContext is an interface to support dynamic dispatch.
type IFieldsCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIELDS() antlr.TerminalNode
	FieldList() IFieldListContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsFieldsCommandContext differentiates from other interfaces.
	IsFieldsCommandContext()
}

type FieldsCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldsCommandContext() *FieldsCommandContext {
	var p = new(FieldsCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldsCommand
	return p
}

func InitEmptyFieldsCommandContext(p *FieldsCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldsCommand
}

func (*FieldsCommandContext) IsFieldsCommandContext() {}

func NewFieldsCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldsCommandContext {
	var p = new(FieldsCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_fieldsCommand

	return p
}

func (s *FieldsCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldsCommandContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(SPLParserFIELDS, 0)
}

func (s *FieldsCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *FieldsCommandContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SPLParserPLUS, 0)
}

func (s *FieldsCommandContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SPLParserMINUS, 0)
}

func (s *FieldsCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldsCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldsCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFieldsCommand(s)
	}
}

func (s *FieldsCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFieldsCommand(s)
	}
}

func (s *FieldsCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFieldsCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FieldsCommand() (localctx IFieldsCommandContext) {
	localctx = NewFieldsCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SPLParserRULE_fieldsCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(274)
		p.Match(SPLParserFIELDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserPLUS || _la == SPLParserMINUS {
		{
			p.SetState(275)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SPLParserPLUS || _la == SPLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(278)
		p.FieldList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameCommandContext is an interface to support dynamic dispatch.
type IRenameCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	AllRenameSpec() []IRenameSpecContext
	RenameSpec(i int) IRenameSpecContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameCommandContext differentiates from other interfaces.
	IsRenameCommandContext()
}

type RenameCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameCommandContext() *RenameCommandContext {
	var p = new(RenameCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_renameCommand
	return p
}

func InitEmptyRenameCommandContext(p *RenameCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_renameCommand
}

func (*RenameCommandContext) IsRenameCommandContext() {}

func NewRenameCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameCommandContext {
	var p = new(RenameCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_renameCommand

	return p
}

func (s *RenameCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameCommandContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SPLParserRENAME, 0)
}

func (s *RenameCommandContext) AllRenameSpec() []IRenameSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameSpecContext); ok {
			len++
		}
	}

	tst := make([]IRenameSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameSpecContext); ok {
			tst[i] = t.(IRenameSpecContext)
			i++
		}
	}

	return tst
}

func (s *RenameCommandContext) RenameSpec(i int) IRenameSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameSpecContext)
}

func (s *RenameCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *RenameCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *RenameCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterRenameCommand(s)
	}
}

func (s *RenameCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitRenameCommand(s)
	}
}

func (s *RenameCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitRenameCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) RenameCommand() (localctx IRenameCommandContext) {
	localctx = NewRenameCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SPLParserRULE_renameCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(SPLParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)
		p.RenameSpec()
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(282)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(283)
			p.RenameSpec()
		}

		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameSpecContext is an interface to support dynamic dispatch.
type IRenameSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	AS() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode

	// IsRenameSpecContext differentiates from other interfaces.
	IsRenameSpecContext()
}

type RenameSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameSpecContext() *RenameSpecContext {
	var p = new(RenameSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_renameSpec
	return p
}

func InitEmptyRenameSpecContext(p *RenameSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_renameSpec
}

func (*RenameSpecContext) IsRenameSpecContext() {}

func NewRenameSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameSpecContext {
	var p = new(RenameSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_renameSpec

	return p
}

func (s *RenameSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameSpecContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameSpecContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *RenameSpecContext) AS() antlr.TerminalNode {
	return s.GetToken(SPLParserAS, 0)
}

func (s *RenameSpecContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *RenameSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterRenameSpec(s)
	}
}

func (s *RenameSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitRenameSpec(s)
	}
}

func (s *RenameSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitRenameSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) RenameSpec() (localctx IRenameSpecContext) {
	localctx = NewRenameSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SPLParserRULE_renameSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.FieldName()
	}
	{
		p.SetState(290)
		p.Match(SPLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(291)
			p.FieldName()
		}

	case SPLParserQUOTED_STRING:
		{
			p.SetState(292)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRexCommandContext is an interface to support dynamic dispatch.
type IRexCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REX() antlr.TerminalNode
	AllRexOption() []IRexOptionContext
	RexOption(i int) IRexOptionContext
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	EQ() antlr.TerminalNode

	// IsRexCommandContext differentiates from other interfaces.
	IsRexCommandContext()
}

type RexCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRexCommandContext() *RexCommandContext {
	var p = new(RexCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_rexCommand
	return p
}

func InitEmptyRexCommandContext(p *RexCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_rexCommand
}

func (*RexCommandContext) IsRexCommandContext() {}

func NewRexCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RexCommandContext {
	var p = new(RexCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_rexCommand

	return p
}

func (s *RexCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *RexCommandContext) REX() antlr.TerminalNode {
	return s.GetToken(SPLParserREX, 0)
}

func (s *RexCommandContext) AllRexOption() []IRexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRexOptionContext); ok {
			len++
		}
	}

	tst := make([]IRexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRexOptionContext); ok {
			tst[i] = t.(IRexOptionContext)
			i++
		}
	}

	return tst
}

func (s *RexCommandContext) RexOption(i int) IRexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRexOptionContext)
}

func (s *RexCommandContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *RexCommandContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *RexCommandContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *RexCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RexCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RexCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterRexCommand(s)
	}
}

func (s *RexCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitRexCommand(s)
	}
}

func (s *RexCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitRexCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) RexCommand() (localctx IRexCommandContext) {
	localctx = NewRexCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SPLParserRULE_rexCommand)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.Match(SPLParserREX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(296)
				p.RexOption()
			}

		}
		p.SetState(301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(302)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(303)
			p.FieldName()
		}
		{
			p.SetState(304)
			p.Match(SPLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(305)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserPIPE, SPLParserRBRACKET:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRexOptionContext is an interface to support dynamic dispatch.
type IRexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode

	// IsRexOptionContext differentiates from other interfaces.
	IsRexOptionContext()
}

type RexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRexOptionContext() *RexOptionContext {
	var p = new(RexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_rexOption
	return p
}

func InitEmptyRexOptionContext(p *RexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_rexOption
}

func (*RexOptionContext) IsRexOptionContext() {}

func NewRexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RexOptionContext {
	var p = new(RexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_rexOption

	return p
}

func (s *RexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RexOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *RexOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *RexOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *RexOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *RexOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *RexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterRexOption(s)
	}
}

func (s *RexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitRexOption(s)
	}
}

func (s *RexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitRexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) RexOption() (localctx IRexOptionContext) {
	localctx = NewRexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SPLParserRULE_rexOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(310)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(311)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(312)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(313)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDedupCommandContext is an interface to support dynamic dispatch.
type IDedupCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEDUP() antlr.TerminalNode
	FieldList() IFieldListContext
	NUMBER() antlr.TerminalNode
	AllDedupOption() []IDedupOptionContext
	DedupOption(i int) IDedupOptionContext

	// IsDedupCommandContext differentiates from other interfaces.
	IsDedupCommandContext()
}

type DedupCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDedupCommandContext() *DedupCommandContext {
	var p = new(DedupCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_dedupCommand
	return p
}

func InitEmptyDedupCommandContext(p *DedupCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_dedupCommand
}

func (*DedupCommandContext) IsDedupCommandContext() {}

func NewDedupCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DedupCommandContext {
	var p = new(DedupCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_dedupCommand

	return p
}

func (s *DedupCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *DedupCommandContext) DEDUP() antlr.TerminalNode {
	return s.GetToken(SPLParserDEDUP, 0)
}

func (s *DedupCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *DedupCommandContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *DedupCommandContext) AllDedupOption() []IDedupOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDedupOptionContext); ok {
			len++
		}
	}

	tst := make([]IDedupOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDedupOptionContext); ok {
			tst[i] = t.(IDedupOptionContext)
			i++
		}
	}

	return tst
}

func (s *DedupCommandContext) DedupOption(i int) IDedupOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDedupOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDedupOptionContext)
}

func (s *DedupCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DedupCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DedupCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterDedupCommand(s)
	}
}

func (s *DedupCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitDedupCommand(s)
	}
}

func (s *DedupCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitDedupCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) DedupCommand() (localctx IDedupCommandContext) {
	localctx = NewDedupCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SPLParserRULE_dedupCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(316)
		p.Match(SPLParserDEDUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserNUMBER {
		{
			p.SetState(317)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(320)
		p.FieldList()
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserIDENTIFIER {
		{
			p.SetState(321)
			p.DedupOption()
		}

		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDedupOptionContext is an interface to support dynamic dispatch.
type IDedupOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode

	// IsDedupOptionContext differentiates from other interfaces.
	IsDedupOptionContext()
}

type DedupOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDedupOptionContext() *DedupOptionContext {
	var p = new(DedupOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_dedupOption
	return p
}

func InitEmptyDedupOptionContext(p *DedupOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_dedupOption
}

func (*DedupOptionContext) IsDedupOptionContext() {}

func NewDedupOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DedupOptionContext {
	var p = new(DedupOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_dedupOption

	return p
}

func (s *DedupOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DedupOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *DedupOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *DedupOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *DedupOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *DedupOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *DedupOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DedupOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DedupOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterDedupOption(s)
	}
}

func (s *DedupOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitDedupOption(s)
	}
}

func (s *DedupOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitDedupOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) DedupOption() (localctx IDedupOptionContext) {
	localctx = NewDedupOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SPLParserRULE_dedupOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(327)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(328)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(329)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(330)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(331)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortCommandContext is an interface to support dynamic dispatch.
type ISortCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SORT() antlr.TerminalNode
	AllSortField() []ISortFieldContext
	SortField(i int) ISortFieldContext
	NUMBER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortCommandContext differentiates from other interfaces.
	IsSortCommandContext()
}

type SortCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCommandContext() *SortCommandContext {
	var p = new(SortCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_sortCommand
	return p
}

func InitEmptySortCommandContext(p *SortCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_sortCommand
}

func (*SortCommandContext) IsSortCommandContext() {}

func NewSortCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCommandContext {
	var p = new(SortCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_sortCommand

	return p
}

func (s *SortCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCommandContext) SORT() antlr.TerminalNode {
	return s.GetToken(SPLParserSORT, 0)
}

func (s *SortCommandContext) AllSortField() []ISortFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortFieldContext); ok {
			len++
		}
	}

	tst := make([]ISortFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortFieldContext); ok {
			tst[i] = t.(ISortFieldContext)
			i++
		}
	}

	return tst
}

func (s *SortCommandContext) SortField(i int) ISortFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortFieldContext)
}

func (s *SortCommandContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *SortCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *SortCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *SortCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSortCommand(s)
	}
}

func (s *SortCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSortCommand(s)
	}
}

func (s *SortCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSortCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) SortCommand() (localctx ISortCommandContext) {
	localctx = NewSortCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SPLParserRULE_sortCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.Match(SPLParserSORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserNUMBER {
		{
			p.SetState(335)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(338)
		p.SortField()
	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(339)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(340)
			p.SortField()
		}

		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortFieldContext is an interface to support dynamic dispatch.
type ISortFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSortFieldContext differentiates from other interfaces.
	IsSortFieldContext()
}

type SortFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortFieldContext() *SortFieldContext {
	var p = new(SortFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_sortField
	return p
}

func InitEmptySortFieldContext(p *SortFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_sortField
}

func (*SortFieldContext) IsSortFieldContext() {}

func NewSortFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortFieldContext {
	var p = new(SortFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_sortField

	return p
}

func (s *SortFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *SortFieldContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SortFieldContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SPLParserPLUS, 0)
}

func (s *SortFieldContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SPLParserMINUS, 0)
}

func (s *SortFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSortField(s)
	}
}

func (s *SortFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSortField(s)
	}
}

func (s *SortFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSortField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) SortField() (localctx ISortFieldContext) {
	localctx = NewSortFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SPLParserRULE_sortField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserPLUS || _la == SPLParserMINUS {
		{
			p.SetState(346)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SPLParserPLUS || _la == SPLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(349)
		p.FieldName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHeadCommandContext is an interface to support dynamic dispatch.
type IHeadCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEAD() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsHeadCommandContext differentiates from other interfaces.
	IsHeadCommandContext()
}

type HeadCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeadCommandContext() *HeadCommandContext {
	var p = new(HeadCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_headCommand
	return p
}

func InitEmptyHeadCommandContext(p *HeadCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_headCommand
}

func (*HeadCommandContext) IsHeadCommandContext() {}

func NewHeadCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HeadCommandContext {
	var p = new(HeadCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_headCommand

	return p
}

func (s *HeadCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *HeadCommandContext) HEAD() antlr.TerminalNode {
	return s.GetToken(SPLParserHEAD, 0)
}

func (s *HeadCommandContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *HeadCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HeadCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HeadCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterHeadCommand(s)
	}
}

func (s *HeadCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitHeadCommand(s)
	}
}

func (s *HeadCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitHeadCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) HeadCommand() (localctx IHeadCommandContext) {
	localctx = NewHeadCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SPLParserRULE_headCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(351)
		p.Match(SPLParserHEAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserNUMBER {
		{
			p.SetState(352)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITailCommandContext is an interface to support dynamic dispatch.
type ITailCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAIL() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsTailCommandContext differentiates from other interfaces.
	IsTailCommandContext()
}

type TailCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTailCommandContext() *TailCommandContext {
	var p = new(TailCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tailCommand
	return p
}

func InitEmptyTailCommandContext(p *TailCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tailCommand
}

func (*TailCommandContext) IsTailCommandContext() {}

func NewTailCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TailCommandContext {
	var p = new(TailCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_tailCommand

	return p
}

func (s *TailCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *TailCommandContext) TAIL() antlr.TerminalNode {
	return s.GetToken(SPLParserTAIL, 0)
}

func (s *TailCommandContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *TailCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TailCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TailCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTailCommand(s)
	}
}

func (s *TailCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTailCommand(s)
	}
}

func (s *TailCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTailCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TailCommand() (localctx ITailCommandContext) {
	localctx = NewTailCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SPLParserRULE_tailCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(SPLParserTAIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserNUMBER {
		{
			p.SetState(356)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopCommandContext is an interface to support dynamic dispatch.
type ITopCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TOP() antlr.TerminalNode
	AllFieldList() []IFieldListContext
	FieldList(i int) IFieldListContext
	NUMBER() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsTopCommandContext differentiates from other interfaces.
	IsTopCommandContext()
}

type TopCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopCommandContext() *TopCommandContext {
	var p = new(TopCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_topCommand
	return p
}

func InitEmptyTopCommandContext(p *TopCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_topCommand
}

func (*TopCommandContext) IsTopCommandContext() {}

func NewTopCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopCommandContext {
	var p = new(TopCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_topCommand

	return p
}

func (s *TopCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *TopCommandContext) TOP() antlr.TerminalNode {
	return s.GetToken(SPLParserTOP, 0)
}

func (s *TopCommandContext) AllFieldList() []IFieldListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldListContext); ok {
			len++
		}
	}

	tst := make([]IFieldListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldListContext); ok {
			tst[i] = t.(IFieldListContext)
			i++
		}
	}

	return tst
}

func (s *TopCommandContext) FieldList(i int) IFieldListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *TopCommandContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *TopCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *TopCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTopCommand(s)
	}
}

func (s *TopCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTopCommand(s)
	}
}

func (s *TopCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTopCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TopCommand() (localctx ITopCommandContext) {
	localctx = NewTopCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SPLParserRULE_topCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(SPLParserTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserNUMBER {
		{
			p.SetState(360)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(363)
		p.FieldList()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY {
		{
			p.SetState(364)
			p.Match(SPLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)
			p.FieldList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRareCommandContext is an interface to support dynamic dispatch.
type IRareCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RARE() antlr.TerminalNode
	AllFieldList() []IFieldListContext
	FieldList(i int) IFieldListContext
	NUMBER() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsRareCommandContext differentiates from other interfaces.
	IsRareCommandContext()
}

type RareCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRareCommandContext() *RareCommandContext {
	var p = new(RareCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_rareCommand
	return p
}

func InitEmptyRareCommandContext(p *RareCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_rareCommand
}

func (*RareCommandContext) IsRareCommandContext() {}

func NewRareCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RareCommandContext {
	var p = new(RareCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_rareCommand

	return p
}

func (s *RareCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *RareCommandContext) RARE() antlr.TerminalNode {
	return s.GetToken(SPLParserRARE, 0)
}

func (s *RareCommandContext) AllFieldList() []IFieldListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldListContext); ok {
			len++
		}
	}

	tst := make([]IFieldListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldListContext); ok {
			tst[i] = t.(IFieldListContext)
			i++
		}
	}

	return tst
}

func (s *RareCommandContext) FieldList(i int) IFieldListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *RareCommandContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *RareCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *RareCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RareCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RareCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterRareCommand(s)
	}
}

func (s *RareCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitRareCommand(s)
	}
}

func (s *RareCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitRareCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) RareCommand() (localctx IRareCommandContext) {
	localctx = NewRareCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SPLParserRULE_rareCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Match(SPLParserRARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserNUMBER {
		{
			p.SetState(369)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(372)
		p.FieldList()
	}
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY {
		{
			p.SetState(373)
			p.Match(SPLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.FieldList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILookupCommandContext is an interface to support dynamic dispatch.
type ILookupCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOKUP() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	FieldList() IFieldListContext
	AllLookupOption() []ILookupOptionContext
	LookupOption(i int) ILookupOptionContext

	// IsLookupCommandContext differentiates from other interfaces.
	IsLookupCommandContext()
}

type LookupCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookupCommandContext() *LookupCommandContext {
	var p = new(LookupCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_lookupCommand
	return p
}

func InitEmptyLookupCommandContext(p *LookupCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_lookupCommand
}

func (*LookupCommandContext) IsLookupCommandContext() {}

func NewLookupCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupCommandContext {
	var p = new(LookupCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_lookupCommand

	return p
}

func (s *LookupCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupCommandContext) LOOKUP() antlr.TerminalNode {
	return s.GetToken(SPLParserLOOKUP, 0)
}

func (s *LookupCommandContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *LookupCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *LookupCommandContext) AllLookupOption() []ILookupOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILookupOptionContext); ok {
			len++
		}
	}

	tst := make([]ILookupOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILookupOptionContext); ok {
			tst[i] = t.(ILookupOptionContext)
			i++
		}
	}

	return tst
}

func (s *LookupCommandContext) LookupOption(i int) ILookupOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookupOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookupOptionContext)
}

func (s *LookupCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookupCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterLookupCommand(s)
	}
}

func (s *LookupCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitLookupCommand(s)
	}
}

func (s *LookupCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitLookupCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) LookupCommand() (localctx ILookupCommandContext) {
	localctx = NewLookupCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SPLParserRULE_lookupCommand)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.Match(SPLParserLOOKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(378)
				p.LookupOption()
			}

		}
		p.SetState(383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(384)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(385)
		p.FieldList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILookupOptionContext is an interface to support dynamic dispatch.
type ILookupOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode

	// IsLookupOptionContext differentiates from other interfaces.
	IsLookupOptionContext()
}

type LookupOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookupOptionContext() *LookupOptionContext {
	var p = new(LookupOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_lookupOption
	return p
}

func InitEmptyLookupOptionContext(p *LookupOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_lookupOption
}

func (*LookupOptionContext) IsLookupOptionContext() {}

func NewLookupOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupOptionContext {
	var p = new(LookupOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_lookupOption

	return p
}

func (s *LookupOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *LookupOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *LookupOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *LookupOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *LookupOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *LookupOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookupOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterLookupOption(s)
	}
}

func (s *LookupOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitLookupOption(s)
	}
}

func (s *LookupOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitLookupOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) LookupOption() (localctx ILookupOptionContext) {
	localctx = NewLookupOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SPLParserRULE_lookupOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(388)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(389)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(390)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(391)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCommandContext is an interface to support dynamic dispatch.
type IJoinCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	Subsearch() ISubsearchContext
	AllJoinOption() []IJoinOptionContext
	JoinOption(i int) IJoinOptionContext
	FieldList() IFieldListContext

	// IsJoinCommandContext differentiates from other interfaces.
	IsJoinCommandContext()
}

type JoinCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCommandContext() *JoinCommandContext {
	var p = new(JoinCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_joinCommand
	return p
}

func InitEmptyJoinCommandContext(p *JoinCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_joinCommand
}

func (*JoinCommandContext) IsJoinCommandContext() {}

func NewJoinCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCommandContext {
	var p = new(JoinCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_joinCommand

	return p
}

func (s *JoinCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCommandContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SPLParserJOIN, 0)
}

func (s *JoinCommandContext) Subsearch() ISubsearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsearchContext)
}

func (s *JoinCommandContext) AllJoinOption() []IJoinOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinOptionContext); ok {
			len++
		}
	}

	tst := make([]IJoinOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinOptionContext); ok {
			tst[i] = t.(IJoinOptionContext)
			i++
		}
	}

	return tst
}

func (s *JoinCommandContext) JoinOption(i int) IJoinOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinOptionContext)
}

func (s *JoinCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *JoinCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterJoinCommand(s)
	}
}

func (s *JoinCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitJoinCommand(s)
	}
}

func (s *JoinCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitJoinCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) JoinCommand() (localctx IJoinCommandContext) {
	localctx = NewJoinCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SPLParserRULE_joinCommand)
	var _la int

	var _alt int

	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)
			p.Match(SPLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SPLParserIDENTIFIER {
			{
				p.SetState(395)
				p.JoinOption()
			}

			p.SetState(400)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(401)
			p.Subsearch()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(402)
			p.Match(SPLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(403)
					p.JoinOption()
				}

			}
			p.SetState(408)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(409)
			p.FieldList()
		}
		{
			p.SetState(410)
			p.Subsearch()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinOptionContext is an interface to support dynamic dispatch.
type IJoinOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode

	// IsJoinOptionContext differentiates from other interfaces.
	IsJoinOptionContext()
}

type JoinOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOptionContext() *JoinOptionContext {
	var p = new(JoinOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_joinOption
	return p
}

func InitEmptyJoinOptionContext(p *JoinOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_joinOption
}

func (*JoinOptionContext) IsJoinOptionContext() {}

func NewJoinOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOptionContext {
	var p = new(JoinOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_joinOption

	return p
}

func (s *JoinOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *JoinOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *JoinOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *JoinOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *JoinOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *JoinOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterJoinOption(s)
	}
}

func (s *JoinOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitJoinOption(s)
	}
}

func (s *JoinOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitJoinOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) JoinOption() (localctx IJoinOptionContext) {
	localctx = NewJoinOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SPLParserRULE_joinOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(415)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(416)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(417)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(418)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAppendCommandContext is an interface to support dynamic dispatch.
type IAppendCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APPEND() antlr.TerminalNode
	Subsearch() ISubsearchContext

	// IsAppendCommandContext differentiates from other interfaces.
	IsAppendCommandContext()
}

type AppendCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAppendCommandContext() *AppendCommandContext {
	var p = new(AppendCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_appendCommand
	return p
}

func InitEmptyAppendCommandContext(p *AppendCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_appendCommand
}

func (*AppendCommandContext) IsAppendCommandContext() {}

func NewAppendCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AppendCommandContext {
	var p = new(AppendCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_appendCommand

	return p
}

func (s *AppendCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *AppendCommandContext) APPEND() antlr.TerminalNode {
	return s.GetToken(SPLParserAPPEND, 0)
}

func (s *AppendCommandContext) Subsearch() ISubsearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsearchContext)
}

func (s *AppendCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AppendCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AppendCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterAppendCommand(s)
	}
}

func (s *AppendCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitAppendCommand(s)
	}
}

func (s *AppendCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitAppendCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) AppendCommand() (localctx IAppendCommandContext) {
	localctx = NewAppendCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SPLParserRULE_appendCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.Match(SPLParserAPPEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(422)
		p.Subsearch()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionCommandContext is an interface to support dynamic dispatch.
type ITransactionCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRANSACTION() antlr.TerminalNode
	FieldList() IFieldListContext
	AllTransactionOption() []ITransactionOptionContext
	TransactionOption(i int) ITransactionOptionContext

	// IsTransactionCommandContext differentiates from other interfaces.
	IsTransactionCommandContext()
}

type TransactionCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionCommandContext() *TransactionCommandContext {
	var p = new(TransactionCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_transactionCommand
	return p
}

func InitEmptyTransactionCommandContext(p *TransactionCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_transactionCommand
}

func (*TransactionCommandContext) IsTransactionCommandContext() {}

func NewTransactionCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionCommandContext {
	var p = new(TransactionCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_transactionCommand

	return p
}

func (s *TransactionCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionCommandContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SPLParserTRANSACTION, 0)
}

func (s *TransactionCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *TransactionCommandContext) AllTransactionOption() []ITransactionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			len++
		}
	}

	tst := make([]ITransactionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionOptionContext); ok {
			tst[i] = t.(ITransactionOptionContext)
			i++
		}
	}

	return tst
}

func (s *TransactionCommandContext) TransactionOption(i int) ITransactionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionOptionContext)
}

func (s *TransactionCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTransactionCommand(s)
	}
}

func (s *TransactionCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTransactionCommand(s)
	}
}

func (s *TransactionCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTransactionCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TransactionCommand() (localctx ITransactionCommandContext) {
	localctx = NewTransactionCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SPLParserRULE_transactionCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Match(SPLParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(425)
		p.FieldList()
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserIDENTIFIER {
		{
			p.SetState(426)
			p.TransactionOption()
		}

		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionOptionContext is an interface to support dynamic dispatch.
type ITransactionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode
	TIME_SPAN() antlr.TerminalNode

	// IsTransactionOptionContext differentiates from other interfaces.
	IsTransactionOptionContext()
}

type TransactionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionOptionContext() *TransactionOptionContext {
	var p = new(TransactionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_transactionOption
	return p
}

func InitEmptyTransactionOptionContext(p *TransactionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_transactionOption
}

func (*TransactionOptionContext) IsTransactionOptionContext() {}

func NewTransactionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionOptionContext {
	var p = new(TransactionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_transactionOption

	return p
}

func (s *TransactionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *TransactionOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *TransactionOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *TransactionOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *TransactionOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *TransactionOptionContext) TIME_SPAN() antlr.TerminalNode {
	return s.GetToken(SPLParserTIME_SPAN, 0)
}

func (s *TransactionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTransactionOption(s)
	}
}

func (s *TransactionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTransactionOption(s)
	}
}

func (s *TransactionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTransactionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TransactionOption() (localctx ITransactionOptionContext) {
	localctx = NewTransactionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SPLParserRULE_transactionOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(432)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(433)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(434)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(435)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(436)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserTIME_SPAN:
		{
			p.SetState(437)
			p.Match(SPLParserTIME_SPAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpathCommandContext is an interface to support dynamic dispatch.
type ISpathCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SPATH() antlr.TerminalNode
	AllSpathOption() []ISpathOptionContext
	SpathOption(i int) ISpathOptionContext

	// IsSpathCommandContext differentiates from other interfaces.
	IsSpathCommandContext()
}

type SpathCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpathCommandContext() *SpathCommandContext {
	var p = new(SpathCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_spathCommand
	return p
}

func InitEmptySpathCommandContext(p *SpathCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_spathCommand
}

func (*SpathCommandContext) IsSpathCommandContext() {}

func NewSpathCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpathCommandContext {
	var p = new(SpathCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_spathCommand

	return p
}

func (s *SpathCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SpathCommandContext) SPATH() antlr.TerminalNode {
	return s.GetToken(SPLParserSPATH, 0)
}

func (s *SpathCommandContext) AllSpathOption() []ISpathOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISpathOptionContext); ok {
			len++
		}
	}

	tst := make([]ISpathOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISpathOptionContext); ok {
			tst[i] = t.(ISpathOptionContext)
			i++
		}
	}

	return tst
}

func (s *SpathCommandContext) SpathOption(i int) ISpathOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpathOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpathOptionContext)
}

func (s *SpathCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpathCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpathCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSpathCommand(s)
	}
}

func (s *SpathCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSpathCommand(s)
	}
}

func (s *SpathCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSpathCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) SpathCommand() (localctx ISpathCommandContext) {
	localctx = NewSpathCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SPLParserRULE_spathCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(440)
		p.Match(SPLParserSPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserIDENTIFIER {
		{
			p.SetState(441)
			p.SpathOption()
		}

		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpathOptionContext is an interface to support dynamic dispatch.
type ISpathOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext

	// IsSpathOptionContext differentiates from other interfaces.
	IsSpathOptionContext()
}

type SpathOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpathOptionContext() *SpathOptionContext {
	var p = new(SpathOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_spathOption
	return p
}

func InitEmptySpathOptionContext(p *SpathOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_spathOption
}

func (*SpathOptionContext) IsSpathOptionContext() {}

func NewSpathOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpathOptionContext {
	var p = new(SpathOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_spathOption

	return p
}

func (s *SpathOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpathOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *SpathOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *SpathOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *SpathOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SpathOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpathOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpathOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSpathOption(s)
	}
}

func (s *SpathOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSpathOption(s)
	}
}

func (s *SpathOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSpathOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) SpathOption() (localctx ISpathOptionContext) {
	localctx = NewSpathOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SPLParserRULE_spathOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(448)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(449)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(450)
			p.FieldName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventstatsCommandContext is an interface to support dynamic dispatch.
type IEventstatsCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENTSTATS() antlr.TerminalNode
	AllStatsFunction() []IStatsFunctionContext
	StatsFunction(i int) IStatsFunctionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldList() IFieldListContext

	// IsEventstatsCommandContext differentiates from other interfaces.
	IsEventstatsCommandContext()
}

type EventstatsCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventstatsCommandContext() *EventstatsCommandContext {
	var p = new(EventstatsCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_eventstatsCommand
	return p
}

func InitEmptyEventstatsCommandContext(p *EventstatsCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_eventstatsCommand
}

func (*EventstatsCommandContext) IsEventstatsCommandContext() {}

func NewEventstatsCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventstatsCommandContext {
	var p = new(EventstatsCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_eventstatsCommand

	return p
}

func (s *EventstatsCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *EventstatsCommandContext) EVENTSTATS() antlr.TerminalNode {
	return s.GetToken(SPLParserEVENTSTATS, 0)
}

func (s *EventstatsCommandContext) AllStatsFunction() []IStatsFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			len++
		}
	}

	tst := make([]IStatsFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatsFunctionContext); ok {
			tst[i] = t.(IStatsFunctionContext)
			i++
		}
	}

	return tst
}

func (s *EventstatsCommandContext) StatsFunction(i int) IStatsFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsFunctionContext)
}

func (s *EventstatsCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *EventstatsCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *EventstatsCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *EventstatsCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *EventstatsCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventstatsCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventstatsCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterEventstatsCommand(s)
	}
}

func (s *EventstatsCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitEventstatsCommand(s)
	}
}

func (s *EventstatsCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitEventstatsCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) EventstatsCommand() (localctx IEventstatsCommandContext) {
	localctx = NewEventstatsCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SPLParserRULE_eventstatsCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Match(SPLParserEVENTSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(454)
		p.StatsFunction()
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(455)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(456)
			p.StatsFunction()
		}

		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY {
		{
			p.SetState(462)
			p.Match(SPLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)
			p.FieldList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStreamstatsCommandContext is an interface to support dynamic dispatch.
type IStreamstatsCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STREAMSTATS() antlr.TerminalNode
	AllStatsFunction() []IStatsFunctionContext
	StatsFunction(i int) IStatsFunctionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldList() IFieldListContext

	// IsStreamstatsCommandContext differentiates from other interfaces.
	IsStreamstatsCommandContext()
}

type StreamstatsCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStreamstatsCommandContext() *StreamstatsCommandContext {
	var p = new(StreamstatsCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_streamstatsCommand
	return p
}

func InitEmptyStreamstatsCommandContext(p *StreamstatsCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_streamstatsCommand
}

func (*StreamstatsCommandContext) IsStreamstatsCommandContext() {}

func NewStreamstatsCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StreamstatsCommandContext {
	var p = new(StreamstatsCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_streamstatsCommand

	return p
}

func (s *StreamstatsCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *StreamstatsCommandContext) STREAMSTATS() antlr.TerminalNode {
	return s.GetToken(SPLParserSTREAMSTATS, 0)
}

func (s *StreamstatsCommandContext) AllStatsFunction() []IStatsFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			len++
		}
	}

	tst := make([]IStatsFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatsFunctionContext); ok {
			tst[i] = t.(IStatsFunctionContext)
			i++
		}
	}

	return tst
}

func (s *StreamstatsCommandContext) StatsFunction(i int) IStatsFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsFunctionContext)
}

func (s *StreamstatsCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *StreamstatsCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *StreamstatsCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *StreamstatsCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *StreamstatsCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StreamstatsCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StreamstatsCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterStreamstatsCommand(s)
	}
}

func (s *StreamstatsCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitStreamstatsCommand(s)
	}
}

func (s *StreamstatsCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitStreamstatsCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) StreamstatsCommand() (localctx IStreamstatsCommandContext) {
	localctx = NewStreamstatsCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SPLParserRULE_streamstatsCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(SPLParserSTREAMSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(467)
		p.StatsFunction()
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(468)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(469)
			p.StatsFunction()
		}

		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY {
		{
			p.SetState(475)
			p.Match(SPLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.FieldList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimechartCommandContext is an interface to support dynamic dispatch.
type ITimechartCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TIMECHART() antlr.TerminalNode
	StatsFunction() IStatsFunctionContext
	AllTimechartOption() []ITimechartOptionContext
	TimechartOption(i int) ITimechartOptionContext
	BY() antlr.TerminalNode
	FieldName() IFieldNameContext

	// IsTimechartCommandContext differentiates from other interfaces.
	IsTimechartCommandContext()
}

type TimechartCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimechartCommandContext() *TimechartCommandContext {
	var p = new(TimechartCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_timechartCommand
	return p
}

func InitEmptyTimechartCommandContext(p *TimechartCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_timechartCommand
}

func (*TimechartCommandContext) IsTimechartCommandContext() {}

func NewTimechartCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimechartCommandContext {
	var p = new(TimechartCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_timechartCommand

	return p
}

func (s *TimechartCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *TimechartCommandContext) TIMECHART() antlr.TerminalNode {
	return s.GetToken(SPLParserTIMECHART, 0)
}

func (s *TimechartCommandContext) StatsFunction() IStatsFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsFunctionContext)
}

func (s *TimechartCommandContext) AllTimechartOption() []ITimechartOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITimechartOptionContext); ok {
			len++
		}
	}

	tst := make([]ITimechartOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITimechartOptionContext); ok {
			tst[i] = t.(ITimechartOptionContext)
			i++
		}
	}

	return tst
}

func (s *TimechartCommandContext) TimechartOption(i int) ITimechartOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimechartOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimechartOptionContext)
}

func (s *TimechartCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *TimechartCommandContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *TimechartCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimechartCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimechartCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTimechartCommand(s)
	}
}

func (s *TimechartCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTimechartCommand(s)
	}
}

func (s *TimechartCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTimechartCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TimechartCommand() (localctx ITimechartCommandContext) {
	localctx = NewTimechartCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SPLParserRULE_timechartCommand)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(479)
		p.Match(SPLParserTIMECHART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(480)
				p.TimechartOption()
			}

		}
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(486)
		p.StatsFunction()
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY {
		{
			p.SetState(487)
			p.Match(SPLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(488)
			p.FieldName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimechartOptionContext is an interface to support dynamic dispatch.
type ITimechartOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode
	TIME_SPAN() antlr.TerminalNode

	// IsTimechartOptionContext differentiates from other interfaces.
	IsTimechartOptionContext()
}

type TimechartOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimechartOptionContext() *TimechartOptionContext {
	var p = new(TimechartOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_timechartOption
	return p
}

func InitEmptyTimechartOptionContext(p *TimechartOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_timechartOption
}

func (*TimechartOptionContext) IsTimechartOptionContext() {}

func NewTimechartOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimechartOptionContext {
	var p = new(TimechartOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_timechartOption

	return p
}

func (s *TimechartOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TimechartOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *TimechartOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *TimechartOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *TimechartOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *TimechartOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *TimechartOptionContext) TIME_SPAN() antlr.TerminalNode {
	return s.GetToken(SPLParserTIME_SPAN, 0)
}

func (s *TimechartOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimechartOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimechartOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTimechartOption(s)
	}
}

func (s *TimechartOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTimechartOption(s)
	}
}

func (s *TimechartOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTimechartOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TimechartOption() (localctx ITimechartOptionContext) {
	localctx = NewTimechartOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SPLParserRULE_timechartOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(492)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(493)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(494)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(495)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserTIME_SPAN:
		{
			p.SetState(496)
			p.Match(SPLParserTIME_SPAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChartCommandContext is an interface to support dynamic dispatch.
type IChartCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHART() antlr.TerminalNode
	StatsFunction() IStatsFunctionContext
	BY() antlr.TerminalNode
	FieldList() IFieldListContext
	OVER() antlr.TerminalNode
	FieldName() IFieldNameContext

	// IsChartCommandContext differentiates from other interfaces.
	IsChartCommandContext()
}

type ChartCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChartCommandContext() *ChartCommandContext {
	var p = new(ChartCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_chartCommand
	return p
}

func InitEmptyChartCommandContext(p *ChartCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_chartCommand
}

func (*ChartCommandContext) IsChartCommandContext() {}

func NewChartCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChartCommandContext {
	var p = new(ChartCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_chartCommand

	return p
}

func (s *ChartCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ChartCommandContext) CHART() antlr.TerminalNode {
	return s.GetToken(SPLParserCHART, 0)
}

func (s *ChartCommandContext) StatsFunction() IStatsFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsFunctionContext)
}

func (s *ChartCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *ChartCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *ChartCommandContext) OVER() antlr.TerminalNode {
	return s.GetToken(SPLParserOVER, 0)
}

func (s *ChartCommandContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *ChartCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChartCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChartCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterChartCommand(s)
	}
}

func (s *ChartCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitChartCommand(s)
	}
}

func (s *ChartCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitChartCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ChartCommand() (localctx IChartCommandContext) {
	localctx = NewChartCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SPLParserRULE_chartCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Match(SPLParserCHART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(500)
		p.StatsFunction()
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY {
		{
			p.SetState(501)
			p.Match(SPLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.FieldList()
		}

	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserOVER {
		{
			p.SetState(505)
			p.Match(SPLParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(506)
			p.FieldName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFillnullCommandContext is an interface to support dynamic dispatch.
type IFillnullCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILLNULL() antlr.TerminalNode
	AllFillnullOption() []IFillnullOptionContext
	FillnullOption(i int) IFillnullOptionContext
	FieldList() IFieldListContext

	// IsFillnullCommandContext differentiates from other interfaces.
	IsFillnullCommandContext()
}

type FillnullCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFillnullCommandContext() *FillnullCommandContext {
	var p = new(FillnullCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fillnullCommand
	return p
}

func InitEmptyFillnullCommandContext(p *FillnullCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fillnullCommand
}

func (*FillnullCommandContext) IsFillnullCommandContext() {}

func NewFillnullCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FillnullCommandContext {
	var p = new(FillnullCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_fillnullCommand

	return p
}

func (s *FillnullCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *FillnullCommandContext) FILLNULL() antlr.TerminalNode {
	return s.GetToken(SPLParserFILLNULL, 0)
}

func (s *FillnullCommandContext) AllFillnullOption() []IFillnullOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFillnullOptionContext); ok {
			len++
		}
	}

	tst := make([]IFillnullOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFillnullOptionContext); ok {
			tst[i] = t.(IFillnullOptionContext)
			i++
		}
	}

	return tst
}

func (s *FillnullCommandContext) FillnullOption(i int) IFillnullOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFillnullOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFillnullOptionContext)
}

func (s *FillnullCommandContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *FillnullCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FillnullCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FillnullCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFillnullCommand(s)
	}
}

func (s *FillnullCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFillnullCommand(s)
	}
}

func (s *FillnullCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFillnullCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FillnullCommand() (localctx IFillnullCommandContext) {
	localctx = NewFillnullCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SPLParserRULE_fillnullCommand)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Match(SPLParserFILLNULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(510)
				p.FillnullOption()
			}

		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-40)) & ^0x3f) == 0 && ((int64(1)<<(_la-40))&1107296269) != 0 {
		{
			p.SetState(516)
			p.FieldList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFillnullOptionContext is an interface to support dynamic dispatch.
type IFillnullOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsFillnullOptionContext differentiates from other interfaces.
	IsFillnullOptionContext()
}

type FillnullOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFillnullOptionContext() *FillnullOptionContext {
	var p = new(FillnullOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fillnullOption
	return p
}

func InitEmptyFillnullOptionContext(p *FillnullOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fillnullOption
}

func (*FillnullOptionContext) IsFillnullOptionContext() {}

func NewFillnullOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FillnullOptionContext {
	var p = new(FillnullOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_fillnullOption

	return p
}

func (s *FillnullOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FillnullOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *FillnullOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *FillnullOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *FillnullOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *FillnullOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FillnullOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FillnullOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFillnullOption(s)
	}
}

func (s *FillnullOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFillnullOption(s)
	}
}

func (s *FillnullOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFillnullOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FillnullOption() (localctx IFillnullOptionContext) {
	localctx = NewFillnullOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SPLParserRULE_fillnullOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(520)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(521)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SPLParserQUOTED_STRING || _la == SPLParserNUMBER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakemvCommandContext is an interface to support dynamic dispatch.
type IMakemvCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAKEMV() antlr.TerminalNode
	FieldName() IFieldNameContext
	AllMakemvOption() []IMakemvOptionContext
	MakemvOption(i int) IMakemvOptionContext

	// IsMakemvCommandContext differentiates from other interfaces.
	IsMakemvCommandContext()
}

type MakemvCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakemvCommandContext() *MakemvCommandContext {
	var p = new(MakemvCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_makemvCommand
	return p
}

func InitEmptyMakemvCommandContext(p *MakemvCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_makemvCommand
}

func (*MakemvCommandContext) IsMakemvCommandContext() {}

func NewMakemvCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakemvCommandContext {
	var p = new(MakemvCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_makemvCommand

	return p
}

func (s *MakemvCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *MakemvCommandContext) MAKEMV() antlr.TerminalNode {
	return s.GetToken(SPLParserMAKEMV, 0)
}

func (s *MakemvCommandContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *MakemvCommandContext) AllMakemvOption() []IMakemvOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMakemvOptionContext); ok {
			len++
		}
	}

	tst := make([]IMakemvOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMakemvOptionContext); ok {
			tst[i] = t.(IMakemvOptionContext)
			i++
		}
	}

	return tst
}

func (s *MakemvCommandContext) MakemvOption(i int) IMakemvOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakemvOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakemvOptionContext)
}

func (s *MakemvCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakemvCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakemvCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterMakemvCommand(s)
	}
}

func (s *MakemvCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitMakemvCommand(s)
	}
}

func (s *MakemvCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitMakemvCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) MakemvCommand() (localctx IMakemvCommandContext) {
	localctx = NewMakemvCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SPLParserRULE_makemvCommand)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Match(SPLParserMAKEMV)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(524)
				p.MakemvOption()
			}

		}
		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(530)
		p.FieldName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakemvOptionContext is an interface to support dynamic dispatch.
type IMakemvOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode

	// IsMakemvOptionContext differentiates from other interfaces.
	IsMakemvOptionContext()
}

type MakemvOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakemvOptionContext() *MakemvOptionContext {
	var p = new(MakemvOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_makemvOption
	return p
}

func InitEmptyMakemvOptionContext(p *MakemvOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_makemvOption
}

func (*MakemvOptionContext) IsMakemvOptionContext() {}

func NewMakemvOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakemvOptionContext {
	var p = new(MakemvOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_makemvOption

	return p
}

func (s *MakemvOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MakemvOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *MakemvOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *MakemvOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *MakemvOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *MakemvOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *MakemvOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakemvOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakemvOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterMakemvOption(s)
	}
}

func (s *MakemvOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitMakemvOption(s)
	}
}

func (s *MakemvOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitMakemvOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) MakemvOption() (localctx IMakemvOptionContext) {
	localctx = NewMakemvOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SPLParserRULE_makemvOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(533)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(534)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(535)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(536)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvexpandCommandContext is an interface to support dynamic dispatch.
type IMvexpandCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MVEXPAND() antlr.TerminalNode
	FieldName() IFieldNameContext

	// IsMvexpandCommandContext differentiates from other interfaces.
	IsMvexpandCommandContext()
}

type MvexpandCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvexpandCommandContext() *MvexpandCommandContext {
	var p = new(MvexpandCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_mvexpandCommand
	return p
}

func InitEmptyMvexpandCommandContext(p *MvexpandCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_mvexpandCommand
}

func (*MvexpandCommandContext) IsMvexpandCommandContext() {}

func NewMvexpandCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvexpandCommandContext {
	var p = new(MvexpandCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_mvexpandCommand

	return p
}

func (s *MvexpandCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *MvexpandCommandContext) MVEXPAND() antlr.TerminalNode {
	return s.GetToken(SPLParserMVEXPAND, 0)
}

func (s *MvexpandCommandContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *MvexpandCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvexpandCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvexpandCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterMvexpandCommand(s)
	}
}

func (s *MvexpandCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitMvexpandCommand(s)
	}
}

func (s *MvexpandCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitMvexpandCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) MvexpandCommand() (localctx IMvexpandCommandContext) {
	localctx = NewMvexpandCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SPLParserRULE_mvexpandCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Match(SPLParserMVEXPAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(540)
		p.FieldName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatCommandContext is an interface to support dynamic dispatch.
type IFormatCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORMAT() antlr.TerminalNode
	AllFormatOption() []IFormatOptionContext
	FormatOption(i int) IFormatOptionContext

	// IsFormatCommandContext differentiates from other interfaces.
	IsFormatCommandContext()
}

type FormatCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormatCommandContext() *FormatCommandContext {
	var p = new(FormatCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_formatCommand
	return p
}

func InitEmptyFormatCommandContext(p *FormatCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_formatCommand
}

func (*FormatCommandContext) IsFormatCommandContext() {}

func NewFormatCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatCommandContext {
	var p = new(FormatCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_formatCommand

	return p
}

func (s *FormatCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatCommandContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SPLParserFORMAT, 0)
}

func (s *FormatCommandContext) AllFormatOption() []IFormatOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormatOptionContext); ok {
			len++
		}
	}

	tst := make([]IFormatOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormatOptionContext); ok {
			tst[i] = t.(IFormatOptionContext)
			i++
		}
	}

	return tst
}

func (s *FormatCommandContext) FormatOption(i int) IFormatOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatOptionContext)
}

func (s *FormatCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFormatCommand(s)
	}
}

func (s *FormatCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFormatCommand(s)
	}
}

func (s *FormatCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFormatCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FormatCommand() (localctx IFormatCommandContext) {
	localctx = NewFormatCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SPLParserRULE_formatCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(SPLParserFORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserIDENTIFIER {
		{
			p.SetState(543)
			p.FormatOption()
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatOptionContext is an interface to support dynamic dispatch.
type IFormatOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsFormatOptionContext differentiates from other interfaces.
	IsFormatOptionContext()
}

type FormatOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormatOptionContext() *FormatOptionContext {
	var p = new(FormatOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_formatOption
	return p
}

func InitEmptyFormatOptionContext(p *FormatOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_formatOption
}

func (*FormatOptionContext) IsFormatOptionContext() {}

func NewFormatOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatOptionContext {
	var p = new(FormatOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_formatOption

	return p
}

func (s *FormatOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *FormatOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *FormatOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *FormatOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *FormatOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFormatOption(s)
	}
}

func (s *FormatOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFormatOption(s)
	}
}

func (s *FormatOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFormatOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FormatOption() (localctx IFormatOptionContext) {
	localctx = NewFormatOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SPLParserRULE_formatOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(549)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(550)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(551)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SPLParserQUOTED_STRING || _la == SPLParserNUMBER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConvertCommandContext is an interface to support dynamic dispatch.
type IConvertCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONVERT() antlr.TerminalNode
	AllConvertFunction() []IConvertFunctionContext
	ConvertFunction(i int) IConvertFunctionContext
	AllConvertOption() []IConvertOptionContext
	ConvertOption(i int) IConvertOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConvertCommandContext differentiates from other interfaces.
	IsConvertCommandContext()
}

type ConvertCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConvertCommandContext() *ConvertCommandContext {
	var p = new(ConvertCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_convertCommand
	return p
}

func InitEmptyConvertCommandContext(p *ConvertCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_convertCommand
}

func (*ConvertCommandContext) IsConvertCommandContext() {}

func NewConvertCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertCommandContext {
	var p = new(ConvertCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_convertCommand

	return p
}

func (s *ConvertCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertCommandContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(SPLParserCONVERT, 0)
}

func (s *ConvertCommandContext) AllConvertFunction() []IConvertFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConvertFunctionContext); ok {
			len++
		}
	}

	tst := make([]IConvertFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConvertFunctionContext); ok {
			tst[i] = t.(IConvertFunctionContext)
			i++
		}
	}

	return tst
}

func (s *ConvertCommandContext) ConvertFunction(i int) IConvertFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertFunctionContext)
}

func (s *ConvertCommandContext) AllConvertOption() []IConvertOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConvertOptionContext); ok {
			len++
		}
	}

	tst := make([]IConvertOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConvertOptionContext); ok {
			tst[i] = t.(IConvertOptionContext)
			i++
		}
	}

	return tst
}

func (s *ConvertCommandContext) ConvertOption(i int) IConvertOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertOptionContext)
}

func (s *ConvertCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *ConvertCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *ConvertCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterConvertCommand(s)
	}
}

func (s *ConvertCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitConvertCommand(s)
	}
}

func (s *ConvertCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitConvertCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ConvertCommand() (localctx IConvertCommandContext) {
	localctx = NewConvertCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SPLParserRULE_convertCommand)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(SPLParserCONVERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(554)
				p.ConvertOption()
			}

		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(560)
		p.ConvertFunction()
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(561)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(562)
			p.ConvertFunction()
		}

		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConvertOptionContext is an interface to support dynamic dispatch.
type IConvertOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsConvertOptionContext differentiates from other interfaces.
	IsConvertOptionContext()
}

type ConvertOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConvertOptionContext() *ConvertOptionContext {
	var p = new(ConvertOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_convertOption
	return p
}

func InitEmptyConvertOptionContext(p *ConvertOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_convertOption
}

func (*ConvertOptionContext) IsConvertOptionContext() {}

func NewConvertOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertOptionContext {
	var p = new(ConvertOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_convertOption

	return p
}

func (s *ConvertOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertOptionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(SPLParserIDENTIFIER)
}

func (s *ConvertOptionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, i)
}

func (s *ConvertOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *ConvertOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *ConvertOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *ConvertOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterConvertOption(s)
	}
}

func (s *ConvertOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitConvertOption(s)
	}
}

func (s *ConvertOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitConvertOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ConvertOption() (localctx IConvertOptionContext) {
	localctx = NewConvertOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SPLParserRULE_convertOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(569)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(570)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&37) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConvertFunctionContext is an interface to support dynamic dispatch.
type IConvertFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode

	// IsConvertFunctionContext differentiates from other interfaces.
	IsConvertFunctionContext()
}

type ConvertFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConvertFunctionContext() *ConvertFunctionContext {
	var p = new(ConvertFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_convertFunction
	return p
}

func InitEmptyConvertFunctionContext(p *ConvertFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_convertFunction
}

func (*ConvertFunctionContext) IsConvertFunctionContext() {}

func NewConvertFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertFunctionContext {
	var p = new(ConvertFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_convertFunction

	return p
}

func (s *ConvertFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertFunctionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *ConvertFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserLPAREN, 0)
}

func (s *ConvertFunctionContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *ConvertFunctionContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *ConvertFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserRPAREN, 0)
}

func (s *ConvertFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(SPLParserAS, 0)
}

func (s *ConvertFunctionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *ConvertFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterConvertFunction(s)
	}
}

func (s *ConvertFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitConvertFunction(s)
	}
}

func (s *ConvertFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitConvertFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ConvertFunction() (localctx IConvertFunctionContext) {
	localctx = NewConvertFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SPLParserRULE_convertFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(573)
		p.Match(SPLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(574)
		p.FieldName()
	}
	{
		p.SetState(575)
		p.Match(SPLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserAS {
		{
			p.SetState(576)
			p.Match(SPLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
			{
				p.SetState(577)
				p.FieldName()
			}

		case SPLParserQUOTED_STRING:
			{
				p.SetState(578)
				p.Match(SPLParserQUOTED_STRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBucketCommandContext is an interface to support dynamic dispatch.
type IBucketCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	BUCKET() antlr.TerminalNode
	BIN() antlr.TerminalNode
	AllBucketOption() []IBucketOptionContext
	BucketOption(i int) IBucketOptionContext

	// IsBucketCommandContext differentiates from other interfaces.
	IsBucketCommandContext()
}

type BucketCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBucketCommandContext() *BucketCommandContext {
	var p = new(BucketCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_bucketCommand
	return p
}

func InitEmptyBucketCommandContext(p *BucketCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_bucketCommand
}

func (*BucketCommandContext) IsBucketCommandContext() {}

func NewBucketCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BucketCommandContext {
	var p = new(BucketCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_bucketCommand

	return p
}

func (s *BucketCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *BucketCommandContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *BucketCommandContext) BUCKET() antlr.TerminalNode {
	return s.GetToken(SPLParserBUCKET, 0)
}

func (s *BucketCommandContext) BIN() antlr.TerminalNode {
	return s.GetToken(SPLParserBIN, 0)
}

func (s *BucketCommandContext) AllBucketOption() []IBucketOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBucketOptionContext); ok {
			len++
		}
	}

	tst := make([]IBucketOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBucketOptionContext); ok {
			tst[i] = t.(IBucketOptionContext)
			i++
		}
	}

	return tst
}

func (s *BucketCommandContext) BucketOption(i int) IBucketOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketOptionContext)
}

func (s *BucketCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BucketCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BucketCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterBucketCommand(s)
	}
}

func (s *BucketCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitBucketCommand(s)
	}
}

func (s *BucketCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitBucketCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) BucketCommand() (localctx IBucketCommandContext) {
	localctx = NewBucketCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SPLParserRULE_bucketCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(583)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SPLParserBUCKET || _la == SPLParserBIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(584)
		p.FieldName()
	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserIDENTIFIER {
		{
			p.SetState(585)
			p.BucketOption()
		}

		p.SetState(590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBucketOptionContext is an interface to support dynamic dispatch.
type IBucketOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	TIME_SPAN() antlr.TerminalNode

	// IsBucketOptionContext differentiates from other interfaces.
	IsBucketOptionContext()
}

type BucketOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBucketOptionContext() *BucketOptionContext {
	var p = new(BucketOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_bucketOption
	return p
}

func InitEmptyBucketOptionContext(p *BucketOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_bucketOption
}

func (*BucketOptionContext) IsBucketOptionContext() {}

func NewBucketOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BucketOptionContext {
	var p = new(BucketOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_bucketOption

	return p
}

func (s *BucketOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *BucketOptionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(SPLParserIDENTIFIER)
}

func (s *BucketOptionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, i)
}

func (s *BucketOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *BucketOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *BucketOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *BucketOptionContext) TIME_SPAN() antlr.TerminalNode {
	return s.GetToken(SPLParserTIME_SPAN, 0)
}

func (s *BucketOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BucketOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BucketOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterBucketOption(s)
	}
}

func (s *BucketOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitBucketOption(s)
	}
}

func (s *BucketOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitBucketOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) BucketOption() (localctx IBucketOptionContext) {
	localctx = NewBucketOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SPLParserRULE_bucketOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(592)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(593)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&39) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestCommandContext is an interface to support dynamic dispatch.
type IRestCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REST() antlr.TerminalNode
	AllRestArg() []IRestArgContext
	RestArg(i int) IRestArgContext

	// IsRestCommandContext differentiates from other interfaces.
	IsRestCommandContext()
}

type RestCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestCommandContext() *RestCommandContext {
	var p = new(RestCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_restCommand
	return p
}

func InitEmptyRestCommandContext(p *RestCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_restCommand
}

func (*RestCommandContext) IsRestCommandContext() {}

func NewRestCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestCommandContext {
	var p = new(RestCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_restCommand

	return p
}

func (s *RestCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *RestCommandContext) REST() antlr.TerminalNode {
	return s.GetToken(SPLParserREST, 0)
}

func (s *RestCommandContext) AllRestArg() []IRestArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRestArgContext); ok {
			len++
		}
	}

	tst := make([]IRestArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRestArgContext); ok {
			tst[i] = t.(IRestArgContext)
			i++
		}
	}

	return tst
}

func (s *RestCommandContext) RestArg(i int) IRestArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestArgContext)
}

func (s *RestCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterRestCommand(s)
	}
}

func (s *RestCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitRestCommand(s)
	}
}

func (s *RestCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitRestCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) RestCommand() (localctx IRestCommandContext) {
	localctx = NewRestCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SPLParserRULE_restCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Match(SPLParserREST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserIDENTIFIER || _la == SPLParserREST_PATH {
		{
			p.SetState(596)
			p.RestArg()
		}

		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestArgContext is an interface to support dynamic dispatch.
type IRestArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	EQ() antlr.TerminalNode
	Value() IValueContext
	MINUS() antlr.TerminalNode
	REST_PATH() antlr.TerminalNode

	// IsRestArgContext differentiates from other interfaces.
	IsRestArgContext()
}

type RestArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestArgContext() *RestArgContext {
	var p = new(RestArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_restArg
	return p
}

func InitEmptyRestArgContext(p *RestArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_restArg
}

func (*RestArgContext) IsRestArgContext() {}

func NewRestArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestArgContext {
	var p = new(RestArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_restArg

	return p
}

func (s *RestArgContext) GetParser() antlr.Parser { return s.parser }

func (s *RestArgContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(SPLParserIDENTIFIER)
}

func (s *RestArgContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, i)
}

func (s *RestArgContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *RestArgContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *RestArgContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SPLParserMINUS, 0)
}

func (s *RestArgContext) REST_PATH() antlr.TerminalNode {
	return s.GetToken(SPLParserREST_PATH, 0)
}

func (s *RestArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterRestArg(s)
	}
}

func (s *RestArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitRestArg(s)
	}
}

func (s *RestArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitRestArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) RestArg() (localctx IRestArgContext) {
	localctx = NewRestArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SPLParserRULE_restArg)
	var _la int

	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(602)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(603)
			p.Match(SPLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserMINUS {
			{
				p.SetState(604)
				p.Match(SPLParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(607)
				p.Value()
			}

		case 2:
			{
				p.SetState(608)
				p.Match(SPLParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.Match(SPLParserREST_PATH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(612)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITstatsCommandContext is an interface to support dynamic dispatch.
type ITstatsCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TSTATS() antlr.TerminalNode
	AllStatsFunction() []IStatsFunctionContext
	StatsFunction(i int) IStatsFunctionContext
	AllTstatsPreOption() []ITstatsPreOptionContext
	TstatsPreOption(i int) ITstatsPreOptionContext
	FROM() antlr.TerminalNode
	TstatsDatamodel() ITstatsDatamodelContext
	WHERE() antlr.TerminalNode
	SearchExpression() ISearchExpressionContext
	BY() antlr.TerminalNode
	GROUPBY() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTstatsPostOption() []ITstatsPostOptionContext
	TstatsPostOption(i int) ITstatsPostOptionContext
	AllFieldOrQuoted() []IFieldOrQuotedContext
	FieldOrQuoted(i int) IFieldOrQuotedContext

	// IsTstatsCommandContext differentiates from other interfaces.
	IsTstatsCommandContext()
}

type TstatsCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTstatsCommandContext() *TstatsCommandContext {
	var p = new(TstatsCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsCommand
	return p
}

func InitEmptyTstatsCommandContext(p *TstatsCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsCommand
}

func (*TstatsCommandContext) IsTstatsCommandContext() {}

func NewTstatsCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TstatsCommandContext {
	var p = new(TstatsCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_tstatsCommand

	return p
}

func (s *TstatsCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *TstatsCommandContext) TSTATS() antlr.TerminalNode {
	return s.GetToken(SPLParserTSTATS, 0)
}

func (s *TstatsCommandContext) AllStatsFunction() []IStatsFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			len++
		}
	}

	tst := make([]IStatsFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatsFunctionContext); ok {
			tst[i] = t.(IStatsFunctionContext)
			i++
		}
	}

	return tst
}

func (s *TstatsCommandContext) StatsFunction(i int) IStatsFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsFunctionContext)
}

func (s *TstatsCommandContext) AllTstatsPreOption() []ITstatsPreOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITstatsPreOptionContext); ok {
			len++
		}
	}

	tst := make([]ITstatsPreOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITstatsPreOptionContext); ok {
			tst[i] = t.(ITstatsPreOptionContext)
			i++
		}
	}

	return tst
}

func (s *TstatsCommandContext) TstatsPreOption(i int) ITstatsPreOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITstatsPreOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITstatsPreOptionContext)
}

func (s *TstatsCommandContext) FROM() antlr.TerminalNode {
	return s.GetToken(SPLParserFROM, 0)
}

func (s *TstatsCommandContext) TstatsDatamodel() ITstatsDatamodelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITstatsDatamodelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITstatsDatamodelContext)
}

func (s *TstatsCommandContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SPLParserWHERE, 0)
}

func (s *TstatsCommandContext) SearchExpression() ISearchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchExpressionContext)
}

func (s *TstatsCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *TstatsCommandContext) GROUPBY() antlr.TerminalNode {
	return s.GetToken(SPLParserGROUPBY, 0)
}

func (s *TstatsCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *TstatsCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *TstatsCommandContext) AllTstatsPostOption() []ITstatsPostOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITstatsPostOptionContext); ok {
			len++
		}
	}

	tst := make([]ITstatsPostOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITstatsPostOptionContext); ok {
			tst[i] = t.(ITstatsPostOptionContext)
			i++
		}
	}

	return tst
}

func (s *TstatsCommandContext) TstatsPostOption(i int) ITstatsPostOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITstatsPostOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITstatsPostOptionContext)
}

func (s *TstatsCommandContext) AllFieldOrQuoted() []IFieldOrQuotedContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldOrQuotedContext); ok {
			len++
		}
	}

	tst := make([]IFieldOrQuotedContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldOrQuotedContext); ok {
			tst[i] = t.(IFieldOrQuotedContext)
			i++
		}
	}

	return tst
}

func (s *TstatsCommandContext) FieldOrQuoted(i int) IFieldOrQuotedContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrQuotedContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrQuotedContext)
}

func (s *TstatsCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TstatsCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TstatsCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTstatsCommand(s)
	}
}

func (s *TstatsCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTstatsCommand(s)
	}
}

func (s *TstatsCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTstatsCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TstatsCommand() (localctx ITstatsCommandContext) {
	localctx = NewTstatsCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SPLParserRULE_tstatsCommand)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Match(SPLParserTSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(616)
				p.TstatsPreOption()
			}

		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(622)
		p.StatsFunction()
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA || _la == SPLParserIDENTIFIER {
		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserCOMMA {
			{
				p.SetState(623)
				p.Match(SPLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(626)
			p.StatsFunction()
		}

		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserFROM {
		{
			p.SetState(632)
			p.Match(SPLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(633)
			p.TstatsDatamodel()
		}

	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserWHERE {
		{
			p.SetState(636)
			p.Match(SPLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(637)
			p.SearchExpression()
		}

	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY || _la == SPLParserGROUPBY {
		{
			p.SetState(640)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SPLParserBY || _la == SPLParserGROUPBY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-40)) & ^0x3f) == 0 && ((int64(1)<<(_la-40))&1107296269) != 0) {
			p.SetState(643)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(641)
					p.TstatsPostOption()
				}

			case 2:
				{
					p.SetState(642)
					p.FieldOrQuoted()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(645)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITstatsPreOptionContext is an interface to support dynamic dispatch.
type ITstatsPreOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode
	TIME_SPAN() antlr.TerminalNode
	MACRO() antlr.TerminalNode

	// IsTstatsPreOptionContext differentiates from other interfaces.
	IsTstatsPreOptionContext()
}

type TstatsPreOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTstatsPreOptionContext() *TstatsPreOptionContext {
	var p = new(TstatsPreOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsPreOption
	return p
}

func InitEmptyTstatsPreOptionContext(p *TstatsPreOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsPreOption
}

func (*TstatsPreOptionContext) IsTstatsPreOptionContext() {}

func NewTstatsPreOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TstatsPreOptionContext {
	var p = new(TstatsPreOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_tstatsPreOption

	return p
}

func (s *TstatsPreOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TstatsPreOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *TstatsPreOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *TstatsPreOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *TstatsPreOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *TstatsPreOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *TstatsPreOptionContext) TIME_SPAN() antlr.TerminalNode {
	return s.GetToken(SPLParserTIME_SPAN, 0)
}

func (s *TstatsPreOptionContext) MACRO() antlr.TerminalNode {
	return s.GetToken(SPLParserMACRO, 0)
}

func (s *TstatsPreOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TstatsPreOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TstatsPreOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTstatsPreOption(s)
	}
}

func (s *TstatsPreOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTstatsPreOption(s)
	}
}

func (s *TstatsPreOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTstatsPreOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TstatsPreOption() (localctx ITstatsPreOptionContext) {
	localctx = NewTstatsPreOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SPLParserRULE_tstatsPreOption)
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(649)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(650)
			p.Match(SPLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SPLParserQUOTED_STRING:
			{
				p.SetState(651)
				p.Match(SPLParserQUOTED_STRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
			{
				p.SetState(652)
				p.FieldName()
			}

		case SPLParserNUMBER:
			{
				p.SetState(653)
				p.Match(SPLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SPLParserTIME_SPAN:
			{
				p.SetState(654)
				p.Match(SPLParserTIME_SPAN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case SPLParserMACRO:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(657)
			p.Match(SPLParserMACRO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITstatsDatamodelContext is an interface to support dynamic dispatch.
type ITstatsDatamodelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	EQ() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsTstatsDatamodelContext differentiates from other interfaces.
	IsTstatsDatamodelContext()
}

type TstatsDatamodelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTstatsDatamodelContext() *TstatsDatamodelContext {
	var p = new(TstatsDatamodelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsDatamodel
	return p
}

func InitEmptyTstatsDatamodelContext(p *TstatsDatamodelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsDatamodel
}

func (*TstatsDatamodelContext) IsTstatsDatamodelContext() {}

func NewTstatsDatamodelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TstatsDatamodelContext {
	var p = new(TstatsDatamodelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_tstatsDatamodel

	return p
}

func (s *TstatsDatamodelContext) GetParser() antlr.Parser { return s.parser }

func (s *TstatsDatamodelContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(SPLParserIDENTIFIER)
}

func (s *TstatsDatamodelContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, i)
}

func (s *TstatsDatamodelContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *TstatsDatamodelContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SPLParserDOT)
}

func (s *TstatsDatamodelContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserDOT, i)
}

func (s *TstatsDatamodelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TstatsDatamodelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TstatsDatamodelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTstatsDatamodel(s)
	}
}

func (s *TstatsDatamodelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTstatsDatamodel(s)
	}
}

func (s *TstatsDatamodelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTstatsDatamodel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TstatsDatamodel() (localctx ITstatsDatamodelContext) {
	localctx = NewTstatsDatamodelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SPLParserRULE_tstatsDatamodel)
	var _la int

	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(660)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(661)
			p.Match(SPLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(662)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SPLParserDOT {
			{
				p.SetState(663)
				p.Match(SPLParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(664)
				p.Match(SPLParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(669)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(670)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SPLParserDOT {
			{
				p.SetState(671)
				p.Match(SPLParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(672)
				p.Match(SPLParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(677)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITstatsPostOptionContext is an interface to support dynamic dispatch.
type ITstatsPostOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode
	TIME_SPAN() antlr.TerminalNode

	// IsTstatsPostOptionContext differentiates from other interfaces.
	IsTstatsPostOptionContext()
}

type TstatsPostOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTstatsPostOptionContext() *TstatsPostOptionContext {
	var p = new(TstatsPostOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsPostOption
	return p
}

func InitEmptyTstatsPostOptionContext(p *TstatsPostOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_tstatsPostOption
}

func (*TstatsPostOptionContext) IsTstatsPostOptionContext() {}

func NewTstatsPostOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TstatsPostOptionContext {
	var p = new(TstatsPostOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_tstatsPostOption

	return p
}

func (s *TstatsPostOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TstatsPostOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *TstatsPostOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *TstatsPostOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *TstatsPostOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *TstatsPostOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *TstatsPostOptionContext) TIME_SPAN() antlr.TerminalNode {
	return s.GetToken(SPLParserTIME_SPAN, 0)
}

func (s *TstatsPostOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TstatsPostOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TstatsPostOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterTstatsPostOption(s)
	}
}

func (s *TstatsPostOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitTstatsPostOption(s)
	}
}

func (s *TstatsPostOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitTstatsPostOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) TstatsPostOption() (localctx ITstatsPostOptionContext) {
	localctx = NewTstatsPostOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SPLParserRULE_tstatsPostOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(681)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(682)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(683)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(684)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserTIME_SPAN:
		{
			p.SetState(685)
			p.Match(SPLParserTIME_SPAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMstatsCommandContext is an interface to support dynamic dispatch.
type IMstatsCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MSTATS() antlr.TerminalNode
	AllStatsFunction() []IStatsFunctionContext
	StatsFunction(i int) IStatsFunctionContext
	AllTstatsPreOption() []ITstatsPreOptionContext
	TstatsPreOption(i int) ITstatsPreOptionContext
	WHERE() antlr.TerminalNode
	SearchExpression() ISearchExpressionContext
	BY() antlr.TerminalNode
	GROUPBY() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTstatsPostOption() []ITstatsPostOptionContext
	TstatsPostOption(i int) ITstatsPostOptionContext
	AllFieldOrQuoted() []IFieldOrQuotedContext
	FieldOrQuoted(i int) IFieldOrQuotedContext

	// IsMstatsCommandContext differentiates from other interfaces.
	IsMstatsCommandContext()
}

type MstatsCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMstatsCommandContext() *MstatsCommandContext {
	var p = new(MstatsCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_mstatsCommand
	return p
}

func InitEmptyMstatsCommandContext(p *MstatsCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_mstatsCommand
}

func (*MstatsCommandContext) IsMstatsCommandContext() {}

func NewMstatsCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MstatsCommandContext {
	var p = new(MstatsCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_mstatsCommand

	return p
}

func (s *MstatsCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *MstatsCommandContext) MSTATS() antlr.TerminalNode {
	return s.GetToken(SPLParserMSTATS, 0)
}

func (s *MstatsCommandContext) AllStatsFunction() []IStatsFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			len++
		}
	}

	tst := make([]IStatsFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatsFunctionContext); ok {
			tst[i] = t.(IStatsFunctionContext)
			i++
		}
	}

	return tst
}

func (s *MstatsCommandContext) StatsFunction(i int) IStatsFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatsFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatsFunctionContext)
}

func (s *MstatsCommandContext) AllTstatsPreOption() []ITstatsPreOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITstatsPreOptionContext); ok {
			len++
		}
	}

	tst := make([]ITstatsPreOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITstatsPreOptionContext); ok {
			tst[i] = t.(ITstatsPreOptionContext)
			i++
		}
	}

	return tst
}

func (s *MstatsCommandContext) TstatsPreOption(i int) ITstatsPreOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITstatsPreOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITstatsPreOptionContext)
}

func (s *MstatsCommandContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SPLParserWHERE, 0)
}

func (s *MstatsCommandContext) SearchExpression() ISearchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchExpressionContext)
}

func (s *MstatsCommandContext) BY() antlr.TerminalNode {
	return s.GetToken(SPLParserBY, 0)
}

func (s *MstatsCommandContext) GROUPBY() antlr.TerminalNode {
	return s.GetToken(SPLParserGROUPBY, 0)
}

func (s *MstatsCommandContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *MstatsCommandContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *MstatsCommandContext) AllTstatsPostOption() []ITstatsPostOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITstatsPostOptionContext); ok {
			len++
		}
	}

	tst := make([]ITstatsPostOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITstatsPostOptionContext); ok {
			tst[i] = t.(ITstatsPostOptionContext)
			i++
		}
	}

	return tst
}

func (s *MstatsCommandContext) TstatsPostOption(i int) ITstatsPostOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITstatsPostOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITstatsPostOptionContext)
}

func (s *MstatsCommandContext) AllFieldOrQuoted() []IFieldOrQuotedContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldOrQuotedContext); ok {
			len++
		}
	}

	tst := make([]IFieldOrQuotedContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldOrQuotedContext); ok {
			tst[i] = t.(IFieldOrQuotedContext)
			i++
		}
	}

	return tst
}

func (s *MstatsCommandContext) FieldOrQuoted(i int) IFieldOrQuotedContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrQuotedContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrQuotedContext)
}

func (s *MstatsCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MstatsCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MstatsCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterMstatsCommand(s)
	}
}

func (s *MstatsCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitMstatsCommand(s)
	}
}

func (s *MstatsCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitMstatsCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) MstatsCommand() (localctx IMstatsCommandContext) {
	localctx = NewMstatsCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SPLParserRULE_mstatsCommand)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(SPLParserMSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(689)
				p.TstatsPreOption()
			}

		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(695)
		p.StatsFunction()
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA || _la == SPLParserIDENTIFIER {
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserCOMMA {
			{
				p.SetState(696)
				p.Match(SPLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(699)
			p.StatsFunction()
		}

		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserWHERE {
		{
			p.SetState(705)
			p.Match(SPLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(706)
			p.SearchExpression()
		}

	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserBY || _la == SPLParserGROUPBY {
		{
			p.SetState(709)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SPLParserBY || _la == SPLParserGROUPBY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-40)) & ^0x3f) == 0 && ((int64(1)<<(_la-40))&1107296269) != 0) {
			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(710)
					p.TstatsPostOption()
				}

			case 2:
				{
					p.SetState(711)
					p.FieldOrQuoted()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(714)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInputlookupCommandContext is an interface to support dynamic dispatch.
type IInputlookupCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INPUTLOOKUP() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	AllInputlookupOption() []IInputlookupOptionContext
	InputlookupOption(i int) IInputlookupOptionContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsInputlookupCommandContext differentiates from other interfaces.
	IsInputlookupCommandContext()
}

type InputlookupCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputlookupCommandContext() *InputlookupCommandContext {
	var p = new(InputlookupCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_inputlookupCommand
	return p
}

func InitEmptyInputlookupCommandContext(p *InputlookupCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_inputlookupCommand
}

func (*InputlookupCommandContext) IsInputlookupCommandContext() {}

func NewInputlookupCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputlookupCommandContext {
	var p = new(InputlookupCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_inputlookupCommand

	return p
}

func (s *InputlookupCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *InputlookupCommandContext) INPUTLOOKUP() antlr.TerminalNode {
	return s.GetToken(SPLParserINPUTLOOKUP, 0)
}

func (s *InputlookupCommandContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *InputlookupCommandContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *InputlookupCommandContext) AllInputlookupOption() []IInputlookupOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInputlookupOptionContext); ok {
			len++
		}
	}

	tst := make([]IInputlookupOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInputlookupOptionContext); ok {
			tst[i] = t.(IInputlookupOptionContext)
			i++
		}
	}

	return tst
}

func (s *InputlookupCommandContext) InputlookupOption(i int) IInputlookupOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputlookupOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputlookupOptionContext)
}

func (s *InputlookupCommandContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SPLParserWHERE, 0)
}

func (s *InputlookupCommandContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InputlookupCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputlookupCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputlookupCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterInputlookupCommand(s)
	}
}

func (s *InputlookupCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitInputlookupCommand(s)
	}
}

func (s *InputlookupCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitInputlookupCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) InputlookupCommand() (localctx IInputlookupCommandContext) {
	localctx = NewInputlookupCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SPLParserRULE_inputlookupCommand)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Match(SPLParserINPUTLOOKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(719)
				p.InputlookupOption()
			}

		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(725)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SPLParserQUOTED_STRING || _la == SPLParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SPLParserWHERE {
		{
			p.SetState(726)
			p.Match(SPLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(727)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInputlookupOptionContext is an interface to support dynamic dispatch.
type IInputlookupOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	FieldName() IFieldNameContext
	NUMBER() antlr.TerminalNode

	// IsInputlookupOptionContext differentiates from other interfaces.
	IsInputlookupOptionContext()
}

type InputlookupOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputlookupOptionContext() *InputlookupOptionContext {
	var p = new(InputlookupOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_inputlookupOption
	return p
}

func InitEmptyInputlookupOptionContext(p *InputlookupOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_inputlookupOption
}

func (*InputlookupOptionContext) IsInputlookupOptionContext() {}

func NewInputlookupOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputlookupOptionContext {
	var p = new(InputlookupOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_inputlookupOption

	return p
}

func (s *InputlookupOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *InputlookupOptionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *InputlookupOptionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *InputlookupOptionContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *InputlookupOptionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *InputlookupOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *InputlookupOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputlookupOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputlookupOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterInputlookupOption(s)
	}
}

func (s *InputlookupOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitInputlookupOption(s)
	}
}

func (s *InputlookupOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitInputlookupOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) InputlookupOption() (localctx IInputlookupOptionContext) {
	localctx = NewInputlookupOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SPLParserRULE_inputlookupOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(731)
		p.Match(SPLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserQUOTED_STRING:
		{
			p.SetState(732)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		{
			p.SetState(733)
			p.FieldName()
		}

	case SPLParserNUMBER:
		{
			p.SetState(734)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericCommandContext is an interface to support dynamic dispatch.
type IGenericCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllGenericArg() []IGenericArgContext
	GenericArg(i int) IGenericArgContext

	// IsGenericCommandContext differentiates from other interfaces.
	IsGenericCommandContext()
}

type GenericCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericCommandContext() *GenericCommandContext {
	var p = new(GenericCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_genericCommand
	return p
}

func InitEmptyGenericCommandContext(p *GenericCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_genericCommand
}

func (*GenericCommandContext) IsGenericCommandContext() {}

func NewGenericCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericCommandContext {
	var p = new(GenericCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_genericCommand

	return p
}

func (s *GenericCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericCommandContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *GenericCommandContext) AllGenericArg() []IGenericArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericArgContext); ok {
			len++
		}
	}

	tst := make([]IGenericArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericArgContext); ok {
			tst[i] = t.(IGenericArgContext)
			i++
		}
	}

	return tst
}

func (s *GenericCommandContext) GenericArg(i int) IGenericArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgContext)
}

func (s *GenericCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterGenericCommand(s)
	}
}

func (s *GenericCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitGenericCommand(s)
	}
}

func (s *GenericCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitGenericCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) GenericCommand() (localctx IGenericCommandContext) {
	localctx = NewGenericCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SPLParserRULE_genericCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-54)) & ^0x3f) == 0 && ((int64(1)<<(_la-54))&96513) != 0 {
		{
			p.SetState(738)
			p.GenericArg()
		}

		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericArgContext is an interface to support dynamic dispatch.
type IGenericArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	EQ() antlr.TerminalNode
	Value() IValueContext
	MINUS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllGenericArg() []IGenericArgContext
	GenericArg(i int) IGenericArgContext

	// IsGenericArgContext differentiates from other interfaces.
	IsGenericArgContext()
}

type GenericArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericArgContext() *GenericArgContext {
	var p = new(GenericArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_genericArg
	return p
}

func InitEmptyGenericArgContext(p *GenericArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_genericArg
}

func (*GenericArgContext) IsGenericArgContext() {}

func NewGenericArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericArgContext {
	var p = new(GenericArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_genericArg

	return p
}

func (s *GenericArgContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericArgContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(SPLParserIDENTIFIER)
}

func (s *GenericArgContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, i)
}

func (s *GenericArgContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *GenericArgContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *GenericArgContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SPLParserMINUS, 0)
}

func (s *GenericArgContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserLPAREN, 0)
}

func (s *GenericArgContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserRPAREN, 0)
}

func (s *GenericArgContext) AllGenericArg() []IGenericArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericArgContext); ok {
			len++
		}
	}

	tst := make([]IGenericArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericArgContext); ok {
			tst[i] = t.(IGenericArgContext)
			i++
		}
	}

	return tst
}

func (s *GenericArgContext) GenericArg(i int) IGenericArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgContext)
}

func (s *GenericArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterGenericArg(s)
	}
}

func (s *GenericArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitGenericArg(s)
	}
}

func (s *GenericArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitGenericArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) GenericArg() (localctx IGenericArgContext) {
	localctx = NewGenericArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SPLParserRULE_genericArg)
	var _la int

	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(744)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserEQ {
			{
				p.SetState(745)
				p.Match(SPLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(747)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SPLParserMINUS {
				{
					p.SetState(746)
					p.Match(SPLParserMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(749)
					p.Value()
				}

			case 2:
				{
					p.SetState(750)
					p.Match(SPLParserIDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserMINUS {
			{
				p.SetState(755)
				p.Match(SPLParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(758)
			p.Value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(759)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-54)) & ^0x3f) == 0 && ((int64(1)<<(_la-54))&96513) != 0 {
			{
				p.SetState(760)
				p.GenericArg()
			}

			p.SetState(765)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(766)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubsearchContext is an interface to support dynamic dispatch.
type ISubsearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACKET() antlr.TerminalNode
	Query() IQueryContext
	RBRACKET() antlr.TerminalNode

	// IsSubsearchContext differentiates from other interfaces.
	IsSubsearchContext()
}

type SubsearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubsearchContext() *SubsearchContext {
	var p = new(SubsearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_subsearch
	return p
}

func InitEmptySubsearchContext(p *SubsearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_subsearch
}

func (*SubsearchContext) IsSubsearchContext() {}

func NewSubsearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubsearchContext {
	var p = new(SubsearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_subsearch

	return p
}

func (s *SubsearchContext) GetParser() antlr.Parser { return s.parser }

func (s *SubsearchContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(SPLParserLBRACKET, 0)
}

func (s *SubsearchContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubsearchContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(SPLParserRBRACKET, 0)
}

func (s *SubsearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubsearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubsearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSubsearch(s)
	}
}

func (s *SubsearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSubsearch(s)
	}
}

func (s *SubsearchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSubsearch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) Subsearch() (localctx ISubsearchContext) {
	localctx = NewSubsearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SPLParserRULE_subsearch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(SPLParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)
		p.Query()
	}
	{
		p.SetState(771)
		p.Match(SPLParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchExpressionContext is an interface to support dynamic dispatch.
type ISearchExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSearchTerm() []ISearchTermContext
	SearchTerm(i int) ISearchTermContext
	AllLogicalOp() []ILogicalOpContext
	LogicalOp(i int) ILogicalOpContext

	// IsSearchExpressionContext differentiates from other interfaces.
	IsSearchExpressionContext()
}

type SearchExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchExpressionContext() *SearchExpressionContext {
	var p = new(SearchExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_searchExpression
	return p
}

func InitEmptySearchExpressionContext(p *SearchExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_searchExpression
}

func (*SearchExpressionContext) IsSearchExpressionContext() {}

func NewSearchExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchExpressionContext {
	var p = new(SearchExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_searchExpression

	return p
}

func (s *SearchExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchExpressionContext) AllSearchTerm() []ISearchTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISearchTermContext); ok {
			len++
		}
	}

	tst := make([]ISearchTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISearchTermContext); ok {
			tst[i] = t.(ISearchTermContext)
			i++
		}
	}

	return tst
}

func (s *SearchExpressionContext) SearchTerm(i int) ISearchTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchTermContext)
}

func (s *SearchExpressionContext) AllLogicalOp() []ILogicalOpContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogicalOpContext); ok {
			len++
		}
	}

	tst := make([]ILogicalOpContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogicalOpContext); ok {
			tst[i] = t.(ILogicalOpContext)
			i++
		}
	}

	return tst
}

func (s *SearchExpressionContext) LogicalOp(i int) ILogicalOpContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOpContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOpContext)
}

func (s *SearchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSearchExpression(s)
	}
}

func (s *SearchExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSearchExpression(s)
	}
}

func (s *SearchExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSearchExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) SearchExpression() (localctx ISearchExpressionContext) {
	localctx = NewSearchExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SPLParserRULE_searchExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.SearchTerm()
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&97967585546469902) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&301) != 0) {
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserAND || _la == SPLParserOR {
			{
				p.SetState(774)
				p.LogicalOp()
			}

		}
		{
			p.SetState(777)
			p.SearchTerm()
		}

		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchTermContext is an interface to support dynamic dispatch.
type ISearchTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	SearchTerm() ISearchTermContext
	LPAREN() antlr.TerminalNode
	SearchExpression() ISearchExpressionContext
	RPAREN() antlr.TerminalNode
	Condition() IConditionContext
	Subsearch() ISubsearchContext
	MACRO() antlr.TerminalNode
	BareWord() IBareWordContext

	// IsSearchTermContext differentiates from other interfaces.
	IsSearchTermContext()
}

type SearchTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchTermContext() *SearchTermContext {
	var p = new(SearchTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_searchTerm
	return p
}

func InitEmptySearchTermContext(p *SearchTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_searchTerm
}

func (*SearchTermContext) IsSearchTermContext() {}

func NewSearchTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchTermContext {
	var p = new(SearchTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_searchTerm

	return p
}

func (s *SearchTermContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchTermContext) NOT() antlr.TerminalNode {
	return s.GetToken(SPLParserNOT, 0)
}

func (s *SearchTermContext) SearchTerm() ISearchTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchTermContext)
}

func (s *SearchTermContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserLPAREN, 0)
}

func (s *SearchTermContext) SearchExpression() ISearchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchExpressionContext)
}

func (s *SearchTermContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserRPAREN, 0)
}

func (s *SearchTermContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SearchTermContext) Subsearch() ISubsearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsearchContext)
}

func (s *SearchTermContext) MACRO() antlr.TerminalNode {
	return s.GetToken(SPLParserMACRO, 0)
}

func (s *SearchTermContext) BareWord() IBareWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBareWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBareWordContext)
}

func (s *SearchTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterSearchTerm(s)
	}
}

func (s *SearchTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitSearchTerm(s)
	}
}

func (s *SearchTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitSearchTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) SearchTerm() (localctx ISearchTermContext) {
	localctx = NewSearchTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SPLParserRULE_searchTerm)
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(783)
			p.Match(SPLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(784)
			p.SearchTerm()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(785)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(786)
			p.SearchExpression()
		}
		{
			p.SetState(787)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(789)
			p.Condition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(790)
			p.Subsearch()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(791)
			p.Match(SPLParserMACRO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(792)
			p.BareWord()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	ComparisonOp() IComparisonOpContext
	Value() IValueContext
	IN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ValueList() IValueListContext
	RPAREN() antlr.TerminalNode
	Subsearch() ISubsearchContext
	FunctionCall() IFunctionCallContext

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_condition
	return p
}

func InitEmptyConditionContext(p *ConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_condition
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *ConditionContext) ComparisonOp() IComparisonOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOpContext)
}

func (s *ConditionContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ConditionContext) IN() antlr.TerminalNode {
	return s.GetToken(SPLParserIN, 0)
}

func (s *ConditionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserLPAREN, 0)
}

func (s *ConditionContext) ValueList() IValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueListContext)
}

func (s *ConditionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserRPAREN, 0)
}

func (s *ConditionContext) Subsearch() ISubsearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsearchContext)
}

func (s *ConditionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SPLParserRULE_condition)
	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(795)
			p.FieldName()
		}
		{
			p.SetState(796)
			p.ComparisonOp()
		}
		{
			p.SetState(797)
			p.Value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(799)
			p.FieldName()
		}
		{
			p.SetState(800)
			p.Match(SPLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(802)
			p.ValueList()
		}
		{
			p.SetState(803)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(805)
			p.FieldName()
		}
		{
			p.SetState(806)
			p.Match(SPLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(807)
			p.Subsearch()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(809)
			p.FunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOpContext is an interface to support dynamic dispatch.
type IComparisonOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GTE() antlr.TerminalNode

	// IsComparisonOpContext differentiates from other interfaces.
	IsComparisonOpContext()
}

type ComparisonOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOpContext() *ComparisonOpContext {
	var p = new(ComparisonOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_comparisonOp
	return p
}

func InitEmptyComparisonOpContext(p *ComparisonOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_comparisonOp
}

func (*ComparisonOpContext) IsComparisonOpContext() {}

func NewComparisonOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOpContext {
	var p = new(ComparisonOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_comparisonOp

	return p
}

func (s *ComparisonOpContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOpContext) EQ() antlr.TerminalNode {
	return s.GetToken(SPLParserEQ, 0)
}

func (s *ComparisonOpContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SPLParserNEQ, 0)
}

func (s *ComparisonOpContext) LT() antlr.TerminalNode {
	return s.GetToken(SPLParserLT, 0)
}

func (s *ComparisonOpContext) GT() antlr.TerminalNode {
	return s.GetToken(SPLParserGT, 0)
}

func (s *ComparisonOpContext) LTE() antlr.TerminalNode {
	return s.GetToken(SPLParserLTE, 0)
}

func (s *ComparisonOpContext) GTE() antlr.TerminalNode {
	return s.GetToken(SPLParserGTE, 0)
}

func (s *ComparisonOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterComparisonOp(s)
	}
}

func (s *ComparisonOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitComparisonOp(s)
	}
}

func (s *ComparisonOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitComparisonOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ComparisonOp() (localctx IComparisonOpContext) {
	localctx = NewComparisonOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SPLParserRULE_comparisonOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1108307720798208) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOpContext is an interface to support dynamic dispatch.
type ILogicalOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsLogicalOpContext differentiates from other interfaces.
	IsLogicalOpContext()
}

type LogicalOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOpContext() *LogicalOpContext {
	var p = new(LogicalOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_logicalOp
	return p
}

func InitEmptyLogicalOpContext(p *LogicalOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_logicalOp
}

func (*LogicalOpContext) IsLogicalOpContext() {}

func NewLogicalOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOpContext {
	var p = new(LogicalOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_logicalOp

	return p
}

func (s *LogicalOpContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOpContext) AND() antlr.TerminalNode {
	return s.GetToken(SPLParserAND, 0)
}

func (s *LogicalOpContext) OR() antlr.TerminalNode {
	return s.GetToken(SPLParserOR, 0)
}

func (s *LogicalOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterLogicalOp(s)
	}
}

func (s *LogicalOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitLogicalOp(s)
	}
}

func (s *LogicalOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitLogicalOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) LogicalOp() (localctx ILogicalOpContext) {
	localctx = NewLogicalOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SPLParserRULE_logicalOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SPLParserAND || _la == SPLParserOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OrExpression() IOrExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) OrExpression() IOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SPLParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.OrExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrExpressionContext is an interface to support dynamic dispatch.
type IOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAndExpression() []IAndExpressionContext
	AndExpression(i int) IAndExpressionContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsOrExpressionContext differentiates from other interfaces.
	IsOrExpressionContext()
}

type OrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExpressionContext() *OrExpressionContext {
	var p = new(OrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_orExpression
	return p
}

func InitEmptyOrExpressionContext(p *OrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_orExpression
}

func (*OrExpressionContext) IsOrExpressionContext() {}

func NewOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExpressionContext {
	var p = new(OrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_orExpression

	return p
}

func (s *OrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExpressionContext) AllAndExpression() []IAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAndExpressionContext); ok {
			tst[i] = t.(IAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrExpressionContext) AndExpression(i int) IAndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *OrExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(SPLParserOR)
}

func (s *OrExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserOR, i)
}

func (s *OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterOrExpression(s)
	}
}

func (s *OrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitOrExpression(s)
	}
}

func (s *OrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) OrExpression() (localctx IOrExpressionContext) {
	localctx = NewOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SPLParserRULE_orExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.AndExpression()
	}
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserOR {
		{
			p.SetState(819)
			p.Match(SPLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(820)
			p.AndExpression()
		}

		p.SetState(825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNotExpression() []INotExpressionContext
	NotExpression(i int) INotExpressionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_andExpression
	return p
}

func InitEmptyAndExpressionContext(p *AndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_andExpression
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) AllNotExpression() []INotExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INotExpressionContext); ok {
			len++
		}
	}

	tst := make([]INotExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INotExpressionContext); ok {
			tst[i] = t.(INotExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExpressionContext) NotExpression(i int) INotExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotExpressionContext)
}

func (s *AndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(SPLParserAND)
}

func (s *AndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserAND, i)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (s *AndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) AndExpression() (localctx IAndExpressionContext) {
	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SPLParserRULE_andExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		p.NotExpression()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4709653603973857802) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&47) != 0) {
		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SPLParserAND {
			{
				p.SetState(827)
				p.Match(SPLParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(830)
			p.NotExpression()
		}

		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotExpressionContext is an interface to support dynamic dispatch.
type INotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	NotExpression() INotExpressionContext
	ComparisonExpression() IComparisonExpressionContext

	// IsNotExpressionContext differentiates from other interfaces.
	IsNotExpressionContext()
}

type NotExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotExpressionContext() *NotExpressionContext {
	var p = new(NotExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_notExpression
	return p
}

func InitEmptyNotExpressionContext(p *NotExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_notExpression
}

func (*NotExpressionContext) IsNotExpressionContext() {}

func NewNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotExpressionContext {
	var p = new(NotExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_notExpression

	return p
}

func (s *NotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SPLParserNOT, 0)
}

func (s *NotExpressionContext) NotExpression() INotExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotExpressionContext)
}

func (s *NotExpressionContext) ComparisonExpression() IComparisonExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExpressionContext)
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) NotExpression() (localctx INotExpressionContext) {
	localctx = NewNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SPLParserRULE_notExpression)
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(836)
			p.Match(SPLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(837)
			p.NotExpression()
		}

	case SPLParserEVAL, SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserLIKE, SPLParserMATCH, SPLParserCIDRMATCH, SPLParserLPAREN, SPLParserLBRACKET, SPLParserMINUS, SPLParserQUOTED_STRING, SPLParserTIME_SPAN, SPLParserNUMBER, SPLParserWILDCARD, SPLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(838)
			p.ComparisonExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExpressionContext is an interface to support dynamic dispatch.
type IComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Condition() IConditionContext
	AllAdditiveExpression() []IAdditiveExpressionContext
	AdditiveExpression(i int) IAdditiveExpressionContext
	ComparisonOp() IComparisonOpContext

	// IsComparisonExpressionContext differentiates from other interfaces.
	IsComparisonExpressionContext()
}

type ComparisonExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExpressionContext() *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_comparisonExpression
	return p
}

func InitEmptyComparisonExpressionContext(p *ComparisonExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_comparisonExpression
}

func (*ComparisonExpressionContext) IsComparisonExpressionContext() {}

func NewComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_comparisonExpression

	return p
}

func (s *ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExpressionContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *ComparisonExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExpressionContext); ok {
			tst[i] = t.(IAdditiveExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ComparisonExpressionContext) ComparisonOp() IComparisonOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOpContext)
}

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ComparisonExpression() (localctx IComparisonExpressionContext) {
	localctx = NewComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SPLParserRULE_comparisonExpression)
	var _la int

	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.Condition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(842)
			p.AdditiveExpression()
		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1108307720798208) != 0 {
			{
				p.SetState(843)
				p.ComparisonOp()
			}
			{
				p.SetState(844)
				p.AdditiveExpression()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpression() []IMultiplicativeExpressionContext
	MultiplicativeExpression(i int) IMultiplicativeExpressionContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_additiveExpression
	return p
}

func InitEmptyAdditiveExpressionContext(p *AdditiveExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_additiveExpression
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExpressionContext); ok {
			tst[i] = t.(IMultiplicativeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SPLParserPLUS)
}

func (s *AdditiveExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserPLUS, i)
}

func (s *AdditiveExpressionContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(SPLParserMINUS)
}

func (s *AdditiveExpressionContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserMINUS, i)
}

func (s *AdditiveExpressionContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SPLParserDOT)
}

func (s *AdditiveExpressionContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserDOT, i)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SPLParserRULE_additiveExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.MultiplicativeExpression()
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(851)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-61)) & ^0x3f) == 0 && ((int64(1)<<(_la-61))&1027) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(852)
				p.MultiplicativeExpression()
			}

		}
		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUnaryExpression() []IUnaryExpressionContext
	UnaryExpression(i int) IUnaryExpressionContext
	AllWILDCARD() []antlr.TerminalNode
	WILDCARD(i int) antlr.TerminalNode
	AllSLASH() []antlr.TerminalNode
	SLASH(i int) antlr.TerminalNode
	AllPERCENT() []antlr.TerminalNode
	PERCENT(i int) antlr.TerminalNode

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_multiplicativeExpression
	return p
}

func InitEmptyMultiplicativeExpressionContext(p *MultiplicativeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_multiplicativeExpression
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllUnaryExpression() []IUnaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IUnaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryExpressionContext); ok {
			tst[i] = t.(IUnaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) UnaryExpression(i int) IUnaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *MultiplicativeExpressionContext) AllWILDCARD() []antlr.TerminalNode {
	return s.GetTokens(SPLParserWILDCARD)
}

func (s *MultiplicativeExpressionContext) WILDCARD(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserWILDCARD, i)
}

func (s *MultiplicativeExpressionContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(SPLParserSLASH)
}

func (s *MultiplicativeExpressionContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserSLASH, i)
}

func (s *MultiplicativeExpressionContext) AllPERCENT() []antlr.TerminalNode {
	return s.GetTokens(SPLParserPERCENT)
}

func (s *MultiplicativeExpressionContext) PERCENT(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserPERCENT, i)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SPLParserRULE_multiplicativeExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.UnaryExpression()
	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(859)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&35) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(860)
				p.UnaryExpression()
			}

		}
		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	UnaryExpression() IUnaryExpressionContext
	PrimaryExpression() IPrimaryExpressionContext

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_unaryExpression
	return p
}

func InitEmptyUnaryExpressionContext(p *UnaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_unaryExpression
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SPLParserMINUS, 0)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) UnaryExpression() (localctx IUnaryExpressionContext) {
	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SPLParserRULE_unaryExpression)
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserMINUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(866)
			p.Match(SPLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(867)
			p.UnaryExpression()
		}

	case SPLParserEVAL, SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserLIKE, SPLParserMATCH, SPLParserCIDRMATCH, SPLParserLPAREN, SPLParserLBRACKET, SPLParserQUOTED_STRING, SPLParserTIME_SPAN, SPLParserNUMBER, SPLParserWILDCARD, SPLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(868)
			p.PrimaryExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	Subsearch() ISubsearchContext
	FunctionCall() IFunctionCallContext
	Value() IValueContext
	FieldName() IFieldNameContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserLPAREN, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserRPAREN, 0)
}

func (s *PrimaryExpressionContext) Subsearch() ISubsearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsearchContext)
}

func (s *PrimaryExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PrimaryExpressionContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *PrimaryExpressionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SPLParserRULE_primaryExpression)
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(871)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(872)
			p.Expression()
		}
		{
			p.SetState(873)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(875)
			p.Subsearch()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(876)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(877)
			p.Value()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(878)
			p.FieldName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ArgumentList() IArgumentListContext
	EVAL() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	CIDRMATCH() antlr.TerminalNode

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *FunctionCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserLPAREN, 0)
}

func (s *FunctionCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SPLParserRPAREN, 0)
}

func (s *FunctionCallContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionCallContext) EVAL() antlr.TerminalNode {
	return s.GetToken(SPLParserEVAL, 0)
}

func (s *FunctionCallContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SPLParserMATCH, 0)
}

func (s *FunctionCallContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SPLParserLIKE, 0)
}

func (s *FunctionCallContext) CIDRMATCH() antlr.TerminalNode {
	return s.GetToken(SPLParserCIDRMATCH, 0)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SPLParserRULE_functionCall)
	var _la int

	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(881)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(882)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4709653603973857800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&47) != 0) {
			{
				p.SetState(883)
				p.ArgumentList()
			}

		}
		{
			p.SetState(886)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserEVAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(887)
			p.Match(SPLParserEVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(888)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4709653603973857800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&47) != 0) {
			{
				p.SetState(889)
				p.ArgumentList()
			}

		}
		{
			p.SetState(892)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserMATCH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(893)
			p.Match(SPLParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(894)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(895)
			p.ArgumentList()
		}
		{
			p.SetState(896)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserLIKE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(898)
			p.Match(SPLParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(899)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(900)
			p.ArgumentList()
		}
		{
			p.SetState(901)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SPLParserCIDRMATCH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(903)
			p.Match(SPLParserCIDRMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(904)
			p.Match(SPLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(905)
			p.ArgumentList()
		}
		{
			p.SetState(906)
			p.Match(SPLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SPLParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		p.Expression()
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(911)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(912)
			p.Expression()
		}

		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUOTED_STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	TIME_SPAN() antlr.TerminalNode
	WildcardValue() IWildcardValueContext
	ColonValue() IColonValueContext
	IDENTIFIER() antlr.TerminalNode

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *ValueContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *ValueContext) TIME_SPAN() antlr.TerminalNode {
	return s.GetToken(SPLParserTIME_SPAN, 0)
}

func (s *ValueContext) WildcardValue() IWildcardValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcardValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcardValueContext)
}

func (s *ValueContext) ColonValue() IColonValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColonValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColonValueContext)
}

func (s *ValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitValue(s)
	}
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SPLParserRULE_value)
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(918)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(919)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(920)
			p.Match(SPLParserTIME_SPAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(921)
			p.WildcardValue()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(922)
			p.ColonValue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(923)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColonValueContext is an interface to support dynamic dispatch.
type IColonValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExtendedIdentifier() []IExtendedIdentifierContext
	ExtendedIdentifier(i int) IExtendedIdentifierContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode

	// IsColonValueContext differentiates from other interfaces.
	IsColonValueContext()
}

type ColonValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColonValueContext() *ColonValueContext {
	var p = new(ColonValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_colonValue
	return p
}

func InitEmptyColonValueContext(p *ColonValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_colonValue
}

func (*ColonValueContext) IsColonValueContext() {}

func NewColonValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColonValueContext {
	var p = new(ColonValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_colonValue

	return p
}

func (s *ColonValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ColonValueContext) AllExtendedIdentifier() []IExtendedIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExtendedIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IExtendedIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExtendedIdentifierContext); ok {
			tst[i] = t.(IExtendedIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColonValueContext) ExtendedIdentifier(i int) IExtendedIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendedIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendedIdentifierContext)
}

func (s *ColonValueContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOLON)
}

func (s *ColonValueContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOLON, i)
}

func (s *ColonValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColonValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColonValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterColonValue(s)
	}
}

func (s *ColonValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitColonValue(s)
	}
}

func (s *ColonValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitColonValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ColonValue() (localctx IColonValueContext) {
	localctx = NewColonValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SPLParserRULE_colonValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.ExtendedIdentifier()
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SPLParserCOLON {
		{
			p.SetState(927)
			p.Match(SPLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(928)
			p.ExtendedIdentifier()
		}

		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendedIdentifierContext is an interface to support dynamic dispatch.
type IExtendedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	AllSLASH() []antlr.TerminalNode
	SLASH(i int) antlr.TerminalNode

	// IsExtendedIdentifierContext differentiates from other interfaces.
	IsExtendedIdentifierContext()
}

type ExtendedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedIdentifierContext() *ExtendedIdentifierContext {
	var p = new(ExtendedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_extendedIdentifier
	return p
}

func InitEmptyExtendedIdentifierContext(p *ExtendedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_extendedIdentifier
}

func (*ExtendedIdentifierContext) IsExtendedIdentifierContext() {}

func NewExtendedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedIdentifierContext {
	var p = new(ExtendedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_extendedIdentifier

	return p
}

func (s *ExtendedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedIdentifierContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(SPLParserIDENTIFIER)
}

func (s *ExtendedIdentifierContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, i)
}

func (s *ExtendedIdentifierContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(SPLParserMINUS)
}

func (s *ExtendedIdentifierContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserMINUS, i)
}

func (s *ExtendedIdentifierContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(SPLParserSLASH)
}

func (s *ExtendedIdentifierContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserSLASH, i)
}

func (s *ExtendedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterExtendedIdentifier(s)
	}
}

func (s *ExtendedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitExtendedIdentifier(s)
	}
}

func (s *ExtendedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitExtendedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ExtendedIdentifier() (localctx IExtendedIdentifierContext) {
	localctx = NewExtendedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SPLParserRULE_extendedIdentifier)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(933)
		p.Match(SPLParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(934)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SPLParserMINUS || _la == SPLParserSLASH) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(935)
				p.Match(SPLParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildcardValueContext is an interface to support dynamic dispatch.
type IWildcardValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllWILDCARD() []antlr.TerminalNode
	WILDCARD(i int) antlr.TerminalNode
	DOLLAR() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsWildcardValueContext differentiates from other interfaces.
	IsWildcardValueContext()
}

type WildcardValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardValueContext() *WildcardValueContext {
	var p = new(WildcardValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_wildcardValue
	return p
}

func InitEmptyWildcardValueContext(p *WildcardValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_wildcardValue
}

func (*WildcardValueContext) IsWildcardValueContext() {}

func NewWildcardValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardValueContext {
	var p = new(WildcardValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_wildcardValue

	return p
}

func (s *WildcardValueContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *WildcardValueContext) AllWILDCARD() []antlr.TerminalNode {
	return s.GetTokens(SPLParserWILDCARD)
}

func (s *WildcardValueContext) WILDCARD(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserWILDCARD, i)
}

func (s *WildcardValueContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SPLParserDOLLAR, 0)
}

func (s *WildcardValueContext) DOT() antlr.TerminalNode {
	return s.GetToken(SPLParserDOT, 0)
}

func (s *WildcardValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterWildcardValue(s)
	}
}

func (s *WildcardValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitWildcardValue(s)
	}
}

func (s *WildcardValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitWildcardValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) WildcardValue() (localctx IWildcardValueContext) {
	localctx = NewWildcardValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SPLParserRULE_wildcardValue)
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(941)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(942)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(943)
			p.Match(SPLParserDOLLAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(944)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(945)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(946)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(947)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(948)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(949)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(950)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(951)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(952)
			p.Match(SPLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(953)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(954)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(955)
			p.Match(SPLParserDOLLAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(956)
			p.Match(SPLParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBareWordContext is an interface to support dynamic dispatch.
type IBareWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	QUOTED_STRING() antlr.TerminalNode
	WildcardValue() IWildcardValueContext

	// IsBareWordContext differentiates from other interfaces.
	IsBareWordContext()
}

type BareWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBareWordContext() *BareWordContext {
	var p = new(BareWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_bareWord
	return p
}

func InitEmptyBareWordContext(p *BareWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_bareWord
}

func (*BareWordContext) IsBareWordContext() {}

func NewBareWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BareWordContext {
	var p = new(BareWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_bareWord

	return p
}

func (s *BareWordContext) GetParser() antlr.Parser { return s.parser }

func (s *BareWordContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *BareWordContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SPLParserNUMBER, 0)
}

func (s *BareWordContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *BareWordContext) WildcardValue() IWildcardValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcardValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcardValueContext)
}

func (s *BareWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BareWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BareWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterBareWord(s)
	}
}

func (s *BareWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitBareWord(s)
	}
}

func (s *BareWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitBareWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) BareWord() (localctx IBareWordContext) {
	localctx = NewBareWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SPLParserRULE_bareWord)
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(959)
			p.Match(SPLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(960)
			p.Match(SPLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(961)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(962)
			p.WildcardValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldNameContext is an interface to support dynamic dispatch.
type IFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	FROM() antlr.TerminalNode
	MSTATS() antlr.TerminalNode
	INPUTLOOKUP() antlr.TerminalNode

	// IsFieldNameContext differentiates from other interfaces.
	IsFieldNameContext()
}

type FieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameContext() *FieldNameContext {
	var p = new(FieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldName
	return p
}

func InitEmptyFieldNameContext(p *FieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldName
}

func (*FieldNameContext) IsFieldNameContext() {}

func NewFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameContext {
	var p = new(FieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_fieldName

	return p
}

func (s *FieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SPLParserIDENTIFIER, 0)
}

func (s *FieldNameContext) FROM() antlr.TerminalNode {
	return s.GetToken(SPLParserFROM, 0)
}

func (s *FieldNameContext) MSTATS() antlr.TerminalNode {
	return s.GetToken(SPLParserMSTATS, 0)
}

func (s *FieldNameContext) INPUTLOOKUP() antlr.TerminalNode {
	return s.GetToken(SPLParserINPUTLOOKUP, 0)
}

func (s *FieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFieldName(s)
	}
}

func (s *FieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFieldName(s)
	}
}

func (s *FieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FieldName() (localctx IFieldNameContext) {
	localctx = NewFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SPLParserRULE_fieldName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-40)) & ^0x3f) == 0 && ((int64(1)<<(_la-40))&1073741837) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldOrQuoted() []IFieldOrQuotedContext
	FieldOrQuoted(i int) IFieldOrQuotedContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllFieldOrQuoted() []IFieldOrQuotedContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldOrQuotedContext); ok {
			len++
		}
	}

	tst := make([]IFieldOrQuotedContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldOrQuotedContext); ok {
			tst[i] = t.(IFieldOrQuotedContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldOrQuoted(i int) IFieldOrQuotedContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrQuotedContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrQuotedContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SPLParserRULE_fieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.FieldOrQuoted()
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(969)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SPLParserCOMMA {
				{
					p.SetState(968)
					p.Match(SPLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(971)
				p.FieldOrQuoted()
			}

		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldOrQuotedContext is an interface to support dynamic dispatch.
type IFieldOrQuotedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	QUOTED_STRING() antlr.TerminalNode

	// IsFieldOrQuotedContext differentiates from other interfaces.
	IsFieldOrQuotedContext()
}

type FieldOrQuotedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOrQuotedContext() *FieldOrQuotedContext {
	var p = new(FieldOrQuotedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldOrQuoted
	return p
}

func InitEmptyFieldOrQuotedContext(p *FieldOrQuotedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_fieldOrQuoted
}

func (*FieldOrQuotedContext) IsFieldOrQuotedContext() {}

func NewFieldOrQuotedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOrQuotedContext {
	var p = new(FieldOrQuotedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_fieldOrQuoted

	return p
}

func (s *FieldOrQuotedContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOrQuotedContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldOrQuotedContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SPLParserQUOTED_STRING, 0)
}

func (s *FieldOrQuotedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOrQuotedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldOrQuotedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterFieldOrQuoted(s)
	}
}

func (s *FieldOrQuotedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitFieldOrQuoted(s)
	}
}

func (s *FieldOrQuotedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitFieldOrQuoted(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) FieldOrQuoted() (localctx IFieldOrQuotedContext) {
	localctx = NewFieldOrQuotedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SPLParserRULE_fieldOrQuoted)
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SPLParserFROM, SPLParserMSTATS, SPLParserINPUTLOOKUP, SPLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.FieldName()
		}

	case SPLParserQUOTED_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(978)
			p.Match(SPLParserQUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueListContext is an interface to support dynamic dispatch.
type IValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValue() []IValueContext
	Value(i int) IValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValueListContext differentiates from other interfaces.
	IsValueListContext()
}

type ValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueListContext() *ValueListContext {
	var p = new(ValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_valueList
	return p
}

func InitEmptyValueListContext(p *ValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SPLParserRULE_valueList
}

func (*ValueListContext) IsValueListContext() {}

func NewValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueListContext {
	var p = new(ValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SPLParserRULE_valueList

	return p
}

func (s *ValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueListContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ValueListContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SPLParserCOMMA)
}

func (s *ValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SPLParserCOMMA, i)
}

func (s *ValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.EnterValueList(s)
	}
}

func (s *ValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SPLParserListener); ok {
		listenerT.ExitValueList(s)
	}
}

func (s *ValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SPLParserVisitor:
		return t.VisitValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SPLParser) ValueList() (localctx IValueListContext) {
	localctx = NewValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SPLParserRULE_valueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.Value()
	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SPLParserCOMMA {
		{
			p.SetState(982)
			p.Match(SPLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.Value()
		}

		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
